/*
Notehub API

The OpenAPI definition for the Notehub.io API.

API version: 1.2.0
Contact: engineering@blues.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package notehub

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
)

// ProjectAPIService ProjectAPI service
type ProjectAPIService service

type ApiAddDeviceToFleetsRequest struct {
	ctx                      context.Context
	ApiService               *ProjectAPIService
	projectOrProductUID      string
	deviceUID                string
	addDeviceToFleetsRequest *AddDeviceToFleetsRequest
}

// The fleets to add to the device. Note that the endpoint takes an array of fleetUIDs, to facilitate multi-fleet devices. Multi-fleet is not yet enabled on all SaaS plans - unless it is supported by the SaaS plan of the project, passing more than a single fleetUID in the array is an error.
func (r ApiAddDeviceToFleetsRequest) AddDeviceToFleetsRequest(addDeviceToFleetsRequest AddDeviceToFleetsRequest) ApiAddDeviceToFleetsRequest {
	r.addDeviceToFleetsRequest = &addDeviceToFleetsRequest
	return r
}

func (r ApiAddDeviceToFleetsRequest) Execute() (*GetDeviceFleets200Response, *http.Response, error) {
	return r.ApiService.AddDeviceToFleetsExecute(r)
}

/*
AddDeviceToFleets Method for AddDeviceToFleets

Add Device to Fleets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiAddDeviceToFleetsRequest
*/
func (a *ProjectAPIService) AddDeviceToFleets(ctx context.Context, projectOrProductUID string, deviceUID string) ApiAddDeviceToFleetsRequest {
	return ApiAddDeviceToFleetsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceFleets200Response
func (a *ProjectAPIService) AddDeviceToFleetsExecute(r ApiAddDeviceToFleetsRequest) (*GetDeviceFleets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceFleets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.AddDeviceToFleets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/fleets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addDeviceToFleetsRequest == nil {
		return localVarReturnValue, nil, reportError("addDeviceToFleetsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addDeviceToFleetsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloneProjectRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	cloneProjectRequest *CloneProjectRequest
}

// Project to be cloned
func (r ApiCloneProjectRequest) CloneProjectRequest(cloneProjectRequest CloneProjectRequest) ApiCloneProjectRequest {
	r.cloneProjectRequest = &cloneProjectRequest
	return r
}

func (r ApiCloneProjectRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.CloneProjectExecute(r)
}

/*
CloneProject Method for CloneProject

Clone a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiCloneProjectRequest
*/
func (a *ProjectAPIService) CloneProject(ctx context.Context, projectOrProductUID string) ApiCloneProjectRequest {
	return ApiCloneProjectRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectAPIService) CloneProjectExecute(r ApiCloneProjectRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.CloneProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloneProjectRequest == nil {
		return localVarReturnValue, nil, reportError("cloneProjectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloneProjectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFleetRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	createFleetRequest  *CreateFleetRequest
}

// Fleet to be added
func (r ApiCreateFleetRequest) CreateFleetRequest(createFleetRequest CreateFleetRequest) ApiCreateFleetRequest {
	r.createFleetRequest = &createFleetRequest
	return r
}

func (r ApiCreateFleetRequest) Execute() (*Fleet, *http.Response, error) {
	return r.ApiService.CreateFleetExecute(r)
}

/*
CreateFleet Method for CreateFleet

Create Fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiCreateFleetRequest
*/
func (a *ProjectAPIService) CreateFleet(ctx context.Context, projectOrProductUID string) ApiCreateFleetRequest {
	return ApiCreateFleetRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return Fleet
func (a *ProjectAPIService) CreateFleetExecute(r ApiCreateFleetRequest) (*Fleet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Fleet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.CreateFleet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFleetRequest == nil {
		return localVarReturnValue, nil, reportError("createFleetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFleetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateProductRequest struct {
	ctx                  context.Context
	ApiService           *ProjectAPIService
	projectOrProductUID  string
	createProductRequest *CreateProductRequest
}

// Product to be created
func (r ApiCreateProductRequest) CreateProductRequest(createProductRequest CreateProductRequest) ApiCreateProductRequest {
	r.createProductRequest = &createProductRequest
	return r
}

func (r ApiCreateProductRequest) Execute() (*Product, *http.Response, error) {
	return r.ApiService.CreateProductExecute(r)
}

/*
CreateProduct Method for CreateProduct

Create Product within a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiCreateProductRequest
*/
func (a *ProjectAPIService) CreateProduct(ctx context.Context, projectOrProductUID string) ApiCreateProductRequest {
	return ApiCreateProductRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return Product
func (a *ProjectAPIService) CreateProductExecute(r ApiCreateProductRequest) (*Product, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.CreateProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createProductRequest == nil {
		return localVarReturnValue, nil, reportError("createProductRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateProjectRequest struct {
	ctx                  context.Context
	ApiService           *ProjectAPIService
	createProjectRequest *CreateProjectRequest
}

// Project to be created
func (r ApiCreateProjectRequest) CreateProjectRequest(createProjectRequest CreateProjectRequest) ApiCreateProjectRequest {
	r.createProjectRequest = &createProjectRequest
	return r
}

func (r ApiCreateProjectRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.CreateProjectExecute(r)
}

/*
CreateProject Method for CreateProject

Create a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateProjectRequest
*/
func (a *ProjectAPIService) CreateProject(ctx context.Context) ApiCreateProjectRequest {
	return ApiCreateProjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectAPIService) CreateProjectExecute(r ApiCreateProjectRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.CreateProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createProjectRequest == nil {
		return localVarReturnValue, nil, reportError("createProjectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createProjectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeviceFromFleetsRequest struct {
	ctx                           context.Context
	ApiService                    *ProjectAPIService
	projectOrProductUID           string
	deviceUID                     string
	deleteDeviceFromFleetsRequest *DeleteDeviceFromFleetsRequest
}

// The fleets to remove from the device. Note that the endpoint takes an array of fleetUIDs, to facilitate multi-fleet devices. Multi-fleet is not yet enabled on all SaaS plans - unless it is supported by the SaaS plan of the project, passing more than a single fleetUID in the array is an error.
func (r ApiDeleteDeviceFromFleetsRequest) DeleteDeviceFromFleetsRequest(deleteDeviceFromFleetsRequest DeleteDeviceFromFleetsRequest) ApiDeleteDeviceFromFleetsRequest {
	r.deleteDeviceFromFleetsRequest = &deleteDeviceFromFleetsRequest
	return r
}

func (r ApiDeleteDeviceFromFleetsRequest) Execute() (*GetDeviceFleets200Response, *http.Response, error) {
	return r.ApiService.DeleteDeviceFromFleetsExecute(r)
}

/*
DeleteDeviceFromFleets Method for DeleteDeviceFromFleets

Remove Device from Fleets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiDeleteDeviceFromFleetsRequest
*/
func (a *ProjectAPIService) DeleteDeviceFromFleets(ctx context.Context, projectOrProductUID string, deviceUID string) ApiDeleteDeviceFromFleetsRequest {
	return ApiDeleteDeviceFromFleetsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceFleets200Response
func (a *ProjectAPIService) DeleteDeviceFromFleetsExecute(r ApiDeleteDeviceFromFleetsRequest) (*GetDeviceFleets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceFleets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteDeviceFromFleets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/fleets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteDeviceFromFleetsRequest == nil {
		return localVarReturnValue, nil, reportError("deleteDeviceFromFleetsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteDeviceFromFleetsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFleetRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	fleetUID            string
}

func (r ApiDeleteFleetRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFleetExecute(r)
}

/*
DeleteFleet Method for DeleteFleet

Delete Fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiDeleteFleetRequest
*/
func (a *ProjectAPIService) DeleteFleet(ctx context.Context, projectOrProductUID string, fleetUID string) ApiDeleteFleetRequest {
	return ApiDeleteFleetRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
func (a *ProjectAPIService) DeleteFleetExecute(r ApiDeleteFleetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteFleet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFleetEnvironmentVariableRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	fleetUID            string
	key                 string
}

func (r ApiDeleteFleetEnvironmentVariableRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.DeleteFleetEnvironmentVariableExecute(r)
}

/*
DeleteFleetEnvironmentVariable Method for DeleteFleetEnvironmentVariable

Delete environment variables of a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@param key The environment variable key to delete.
	@return ApiDeleteFleetEnvironmentVariableRequest
*/
func (a *ProjectAPIService) DeleteFleetEnvironmentVariable(ctx context.Context, projectOrProductUID string, fleetUID string, key string) ApiDeleteFleetEnvironmentVariableRequest {
	return ApiDeleteFleetEnvironmentVariableRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
		key:                 key,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *ProjectAPIService) DeleteFleetEnvironmentVariableExecute(r ApiDeleteFleetEnvironmentVariableRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteFleetEnvironmentVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/environment_variables/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProductRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	productUID          string
}

func (r ApiDeleteProductRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProductExecute(r)
}

/*
DeleteProduct Method for DeleteProduct

Delete a product

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param productUID
	@return ApiDeleteProductRequest
*/
func (a *ProjectAPIService) DeleteProduct(ctx context.Context, projectOrProductUID string, productUID string) ApiDeleteProductRequest {
	return ApiDeleteProductRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		productUID:          productUID,
	}
}

// Execute executes the request
func (a *ProjectAPIService) DeleteProductExecute(r ApiDeleteProductRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteProduct")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/products/{productUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productUID"+"}", url.PathEscape(parameterValueToString(r.productUID, "productUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteProjectRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiDeleteProjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProjectExecute(r)
}

/*
DeleteProject Method for DeleteProject

Delete a Project by ProjectUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiDeleteProjectRequest
*/
func (a *ProjectAPIService) DeleteProject(ctx context.Context, projectOrProductUID string) ApiDeleteProjectRequest {
	return ApiDeleteProjectRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
func (a *ProjectAPIService) DeleteProjectExecute(r ApiDeleteProjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteProject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteProjectEnvironmentVariableRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	key                 string
}

func (r ApiDeleteProjectEnvironmentVariableRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.DeleteProjectEnvironmentVariableExecute(r)
}

/*
DeleteProjectEnvironmentVariable Method for DeleteProjectEnvironmentVariable

Delete an environment variable of a project by key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param key The environment variable key to delete.
	@return ApiDeleteProjectEnvironmentVariableRequest
*/
func (a *ProjectAPIService) DeleteProjectEnvironmentVariable(ctx context.Context, projectOrProductUID string, key string) ApiDeleteProjectEnvironmentVariableRequest {
	return ApiDeleteProjectEnvironmentVariableRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		key:                 key,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *ProjectAPIService) DeleteProjectEnvironmentVariableExecute(r ApiDeleteProjectEnvironmentVariableRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteProjectEnvironmentVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/environment_variables/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDisableGlobalEventTransformationRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiDisableGlobalEventTransformationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableGlobalEventTransformationExecute(r)
}

/*
DisableGlobalEventTransformation Method for DisableGlobalEventTransformation

Disable the project-level event JSONata transformation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiDisableGlobalEventTransformationRequest
*/
func (a *ProjectAPIService) DisableGlobalEventTransformation(ctx context.Context, projectOrProductUID string) ApiDisableGlobalEventTransformationRequest {
	return ApiDisableGlobalEventTransformationRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
func (a *ProjectAPIService) DisableGlobalEventTransformationExecute(r ApiDisableGlobalEventTransformationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DisableGlobalEventTransformation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/global-transformation/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableGlobalEventTransformationRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiEnableGlobalEventTransformationRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableGlobalEventTransformationExecute(r)
}

/*
EnableGlobalEventTransformation Method for EnableGlobalEventTransformation

Enable the project-level event JSONata transformation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiEnableGlobalEventTransformationRequest
*/
func (a *ProjectAPIService) EnableGlobalEventTransformation(ctx context.Context, projectOrProductUID string) ApiEnableGlobalEventTransformationRequest {
	return ApiEnableGlobalEventTransformationRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
func (a *ProjectAPIService) EnableGlobalEventTransformationExecute(r ApiEnableGlobalEventTransformationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.EnableGlobalEventTransformation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/global-transformation/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeviceDfuHistoryRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	deviceUID           string
	firmwareType        string
}

func (r ApiGetDeviceDfuHistoryRequest) Execute() (*DeviceDfuHistory, *http.Response, error) {
	return r.ApiService.GetDeviceDfuHistoryExecute(r)
}

/*
GetDeviceDfuHistory Method for GetDeviceDfuHistory

Get device DFU history for host or Notecard firmware

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param firmwareType
	@return ApiGetDeviceDfuHistoryRequest
*/
func (a *ProjectAPIService) GetDeviceDfuHistory(ctx context.Context, projectOrProductUID string, deviceUID string, firmwareType string) ApiGetDeviceDfuHistoryRequest {
	return ApiGetDeviceDfuHistoryRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		firmwareType:        firmwareType,
	}
}

// Execute executes the request
//
//	@return DeviceDfuHistory
func (a *ProjectAPIService) GetDeviceDfuHistoryExecute(r ApiGetDeviceDfuHistoryRequest) (*DeviceDfuHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceDfuHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetDeviceDfuHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/dfu/{firmwareType}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"firmwareType"+"}", url.PathEscape(parameterValueToString(r.firmwareType, "firmwareType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceDfuStatusRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	deviceUID           string
	firmwareType        string
}

func (r ApiGetDeviceDfuStatusRequest) Execute() (*DeviceDfuStatus, *http.Response, error) {
	return r.ApiService.GetDeviceDfuStatusExecute(r)
}

/*
GetDeviceDfuStatus Method for GetDeviceDfuStatus

Get device DFU history for host or Notecard firmware

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param firmwareType
	@return ApiGetDeviceDfuStatusRequest
*/
func (a *ProjectAPIService) GetDeviceDfuStatus(ctx context.Context, projectOrProductUID string, deviceUID string, firmwareType string) ApiGetDeviceDfuStatusRequest {
	return ApiGetDeviceDfuStatusRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		firmwareType:        firmwareType,
	}
}

// Execute executes the request
//
//	@return DeviceDfuStatus
func (a *ProjectAPIService) GetDeviceDfuStatusExecute(r ApiGetDeviceDfuStatusRequest) (*DeviceDfuStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceDfuStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetDeviceDfuStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/dfu/{firmwareType}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"firmwareType"+"}", url.PathEscape(parameterValueToString(r.firmwareType, "firmwareType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceFleetsRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDeviceFleetsRequest) Execute() (*GetDeviceFleets200Response, *http.Response, error) {
	return r.ApiService.GetDeviceFleetsExecute(r)
}

/*
GetDeviceFleets Method for GetDeviceFleets

Get Device Fleets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceFleetsRequest
*/
func (a *ProjectAPIService) GetDeviceFleets(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceFleetsRequest {
	return ApiGetDeviceFleetsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceFleets200Response
func (a *ProjectAPIService) GetDeviceFleetsExecute(r ApiGetDeviceFleetsRequest) (*GetDeviceFleets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceFleets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetDeviceFleets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/fleets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesDfuHistoryRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	firmwareType        string
	pageSize            *int32
	pageNum             *int32
	sortBy              *string
	sortOrder           *string
	deviceUID           *[]string
	tag                 *[]string
	serialNumber        *[]string
	fleetUID            *string
	notecardFirmware    *[]string
	location            *[]string
	hostFirmware        *[]string
	productUID          *[]string
	sku                 *[]string
}

func (r ApiGetDevicesDfuHistoryRequest) PageSize(pageSize int32) ApiGetDevicesDfuHistoryRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDevicesDfuHistoryRequest) PageNum(pageNum int32) ApiGetDevicesDfuHistoryRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiGetDevicesDfuHistoryRequest) SortBy(sortBy string) ApiGetDevicesDfuHistoryRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetDevicesDfuHistoryRequest) SortOrder(sortOrder string) ApiGetDevicesDfuHistoryRequest {
	r.sortOrder = &sortOrder
	return r
}

// A Device UID.
func (r ApiGetDevicesDfuHistoryRequest) DeviceUID(deviceUID []string) ApiGetDevicesDfuHistoryRequest {
	r.deviceUID = &deviceUID
	return r
}

// Tag filter
func (r ApiGetDevicesDfuHistoryRequest) Tag(tag []string) ApiGetDevicesDfuHistoryRequest {
	r.tag = &tag
	return r
}

// Serial number filter
func (r ApiGetDevicesDfuHistoryRequest) SerialNumber(serialNumber []string) ApiGetDevicesDfuHistoryRequest {
	r.serialNumber = &serialNumber
	return r
}

func (r ApiGetDevicesDfuHistoryRequest) FleetUID(fleetUID string) ApiGetDevicesDfuHistoryRequest {
	r.fleetUID = &fleetUID
	return r
}

// Firmware version filter
func (r ApiGetDevicesDfuHistoryRequest) NotecardFirmware(notecardFirmware []string) ApiGetDevicesDfuHistoryRequest {
	r.notecardFirmware = &notecardFirmware
	return r
}

// Location filter
func (r ApiGetDevicesDfuHistoryRequest) Location(location []string) ApiGetDevicesDfuHistoryRequest {
	r.location = &location
	return r
}

// Host firmware filter
func (r ApiGetDevicesDfuHistoryRequest) HostFirmware(hostFirmware []string) ApiGetDevicesDfuHistoryRequest {
	r.hostFirmware = &hostFirmware
	return r
}

func (r ApiGetDevicesDfuHistoryRequest) ProductUID(productUID []string) ApiGetDevicesDfuHistoryRequest {
	r.productUID = &productUID
	return r
}

// SKU filter
func (r ApiGetDevicesDfuHistoryRequest) Sku(sku []string) ApiGetDevicesDfuHistoryRequest {
	r.sku = &sku
	return r
}

func (r ApiGetDevicesDfuHistoryRequest) Execute() (*DeviceDfuHistoryPage, *http.Response, error) {
	return r.ApiService.GetDevicesDfuHistoryExecute(r)
}

/*
GetDevicesDfuHistory Method for GetDevicesDfuHistory

Get host or Notecard DFU history for all devices that match the filter criteria

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param firmwareType
	@return ApiGetDevicesDfuHistoryRequest
*/
func (a *ProjectAPIService) GetDevicesDfuHistory(ctx context.Context, projectOrProductUID string, firmwareType string) ApiGetDevicesDfuHistoryRequest {
	return ApiGetDevicesDfuHistoryRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		firmwareType:        firmwareType,
	}
}

// Execute executes the request
//
//	@return DeviceDfuHistoryPage
func (a *ProjectAPIService) GetDevicesDfuHistoryExecute(r ApiGetDevicesDfuHistoryRequest) (*DeviceDfuHistoryPage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceDfuHistoryPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetDevicesDfuHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/dfu/{firmwareType}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"firmwareType"+"}", url.PathEscape(parameterValueToString(r.firmwareType, "firmwareType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	} else {
		var defaultValue string = "captured"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", defaultValue, "form", "")
		r.sortBy = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", r.fleetUID, "form", "")
	}
	if r.notecardFirmware != nil {
		t := *r.notecardFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", t, "form", "multi")
		}
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.hostFirmware != nil {
		t := *r.hostFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", t, "form", "multi")
		}
	}
	if r.productUID != nil {
		t := *r.productUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", t, "form", "multi")
		}
	}
	if r.sku != nil {
		t := *r.sku
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sku", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sku", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesDfuStatusRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	firmwareType        string
	pageSize            *int32
	pageNum             *int32
	sortBy              *string
	sortOrder           *string
	deviceUID           *[]string
	tag                 *[]string
	serialNumber        *[]string
	fleetUID            *string
	notecardFirmware    *[]string
	location            *[]string
	hostFirmware        *[]string
	productUID          *[]string
	sku                 *[]string
}

func (r ApiGetDevicesDfuStatusRequest) PageSize(pageSize int32) ApiGetDevicesDfuStatusRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDevicesDfuStatusRequest) PageNum(pageNum int32) ApiGetDevicesDfuStatusRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiGetDevicesDfuStatusRequest) SortBy(sortBy string) ApiGetDevicesDfuStatusRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetDevicesDfuStatusRequest) SortOrder(sortOrder string) ApiGetDevicesDfuStatusRequest {
	r.sortOrder = &sortOrder
	return r
}

// A Device UID.
func (r ApiGetDevicesDfuStatusRequest) DeviceUID(deviceUID []string) ApiGetDevicesDfuStatusRequest {
	r.deviceUID = &deviceUID
	return r
}

// Tag filter
func (r ApiGetDevicesDfuStatusRequest) Tag(tag []string) ApiGetDevicesDfuStatusRequest {
	r.tag = &tag
	return r
}

// Serial number filter
func (r ApiGetDevicesDfuStatusRequest) SerialNumber(serialNumber []string) ApiGetDevicesDfuStatusRequest {
	r.serialNumber = &serialNumber
	return r
}

func (r ApiGetDevicesDfuStatusRequest) FleetUID(fleetUID string) ApiGetDevicesDfuStatusRequest {
	r.fleetUID = &fleetUID
	return r
}

// Firmware version filter
func (r ApiGetDevicesDfuStatusRequest) NotecardFirmware(notecardFirmware []string) ApiGetDevicesDfuStatusRequest {
	r.notecardFirmware = &notecardFirmware
	return r
}

// Location filter
func (r ApiGetDevicesDfuStatusRequest) Location(location []string) ApiGetDevicesDfuStatusRequest {
	r.location = &location
	return r
}

// Host firmware filter
func (r ApiGetDevicesDfuStatusRequest) HostFirmware(hostFirmware []string) ApiGetDevicesDfuStatusRequest {
	r.hostFirmware = &hostFirmware
	return r
}

func (r ApiGetDevicesDfuStatusRequest) ProductUID(productUID []string) ApiGetDevicesDfuStatusRequest {
	r.productUID = &productUID
	return r
}

// SKU filter
func (r ApiGetDevicesDfuStatusRequest) Sku(sku []string) ApiGetDevicesDfuStatusRequest {
	r.sku = &sku
	return r
}

func (r ApiGetDevicesDfuStatusRequest) Execute() (*DeviceDfuStatusPage, *http.Response, error) {
	return r.ApiService.GetDevicesDfuStatusExecute(r)
}

/*
GetDevicesDfuStatus Method for GetDevicesDfuStatus

Get host or Notecard DFU history for all devices that match the filter criteria

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param firmwareType
	@return ApiGetDevicesDfuStatusRequest
*/
func (a *ProjectAPIService) GetDevicesDfuStatus(ctx context.Context, projectOrProductUID string, firmwareType string) ApiGetDevicesDfuStatusRequest {
	return ApiGetDevicesDfuStatusRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		firmwareType:        firmwareType,
	}
}

// Execute executes the request
//
//	@return DeviceDfuStatusPage
func (a *ProjectAPIService) GetDevicesDfuStatusExecute(r ApiGetDevicesDfuStatusRequest) (*DeviceDfuStatusPage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceDfuStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetDevicesDfuStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/dfu/{firmwareType}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"firmwareType"+"}", url.PathEscape(parameterValueToString(r.firmwareType, "firmwareType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	} else {
		var defaultValue string = "captured"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", defaultValue, "form", "")
		r.sortBy = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", r.fleetUID, "form", "")
	}
	if r.notecardFirmware != nil {
		t := *r.notecardFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", t, "form", "multi")
		}
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.hostFirmware != nil {
		t := *r.hostFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", t, "form", "multi")
		}
	}
	if r.productUID != nil {
		t := *r.productUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", t, "form", "multi")
		}
	}
	if r.sku != nil {
		t := *r.sku
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sku", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sku", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirmwareInfoRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	product             *string
	firmwareType        *string
	version             *string
	target              *string
	filename            *string
	md5                 *string
	unpublished         *bool
}

func (r ApiGetFirmwareInfoRequest) Product(product string) ApiGetFirmwareInfoRequest {
	r.product = &product
	return r
}

func (r ApiGetFirmwareInfoRequest) FirmwareType(firmwareType string) ApiGetFirmwareInfoRequest {
	r.firmwareType = &firmwareType
	return r
}

func (r ApiGetFirmwareInfoRequest) Version(version string) ApiGetFirmwareInfoRequest {
	r.version = &version
	return r
}

func (r ApiGetFirmwareInfoRequest) Target(target string) ApiGetFirmwareInfoRequest {
	r.target = &target
	return r
}

func (r ApiGetFirmwareInfoRequest) Filename(filename string) ApiGetFirmwareInfoRequest {
	r.filename = &filename
	return r
}

func (r ApiGetFirmwareInfoRequest) Md5(md5 string) ApiGetFirmwareInfoRequest {
	r.md5 = &md5
	return r
}

func (r ApiGetFirmwareInfoRequest) Unpublished(unpublished bool) ApiGetFirmwareInfoRequest {
	r.unpublished = &unpublished
	return r
}

func (r ApiGetFirmwareInfoRequest) Execute() ([]FirmwareInfo, *http.Response, error) {
	return r.ApiService.GetFirmwareInfoExecute(r)
}

/*
GetFirmwareInfo Method for GetFirmwareInfo

Get Available Firmware Information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetFirmwareInfoRequest
*/
func (a *ProjectAPIService) GetFirmwareInfo(ctx context.Context, projectOrProductUID string) ApiGetFirmwareInfoRequest {
	return ApiGetFirmwareInfoRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return []FirmwareInfo
func (a *ProjectAPIService) GetFirmwareInfoExecute(r ApiGetFirmwareInfoRequest) ([]FirmwareInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FirmwareInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetFirmwareInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/firmware"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.product != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product", r.product, "form", "")
	}
	if r.firmwareType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firmwareType", r.firmwareType, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.target != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target", r.target, "form", "")
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.md5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "md5", r.md5, "form", "")
	}
	if r.unpublished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unpublished", r.unpublished, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	fleetUID            string
}

func (r ApiGetFleetRequest) Execute() (*Fleet, *http.Response, error) {
	return r.ApiService.GetFleetExecute(r)
}

/*
GetFleet Method for GetFleet

Get Fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiGetFleetRequest
*/
func (a *ProjectAPIService) GetFleet(ctx context.Context, projectOrProductUID string, fleetUID string) ApiGetFleetRequest {
	return ApiGetFleetRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return Fleet
func (a *ProjectAPIService) GetFleetExecute(r ApiGetFleetRequest) (*Fleet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Fleet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetFleet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetEnvironmentHierarchyRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	fleetUID            string
}

func (r ApiGetFleetEnvironmentHierarchyRequest) Execute() (*EnvTreeJsonNode, *http.Response, error) {
	return r.ApiService.GetFleetEnvironmentHierarchyExecute(r)
}

/*
GetFleetEnvironmentHierarchy Get environment variable hierarchy for a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiGetFleetEnvironmentHierarchyRequest
*/
func (a *ProjectAPIService) GetFleetEnvironmentHierarchy(ctx context.Context, projectOrProductUID string, fleetUID string) ApiGetFleetEnvironmentHierarchyRequest {
	return ApiGetFleetEnvironmentHierarchyRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return EnvTreeJsonNode
func (a *ProjectAPIService) GetFleetEnvironmentHierarchyExecute(r ApiGetFleetEnvironmentHierarchyRequest) (*EnvTreeJsonNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvTreeJsonNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetFleetEnvironmentHierarchy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/environment_hierarchy"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetEnvironmentVariablesRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	fleetUID            string
}

func (r ApiGetFleetEnvironmentVariablesRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.GetFleetEnvironmentVariablesExecute(r)
}

/*
GetFleetEnvironmentVariables Method for GetFleetEnvironmentVariables

Get environment variables of a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiGetFleetEnvironmentVariablesRequest
*/
func (a *ProjectAPIService) GetFleetEnvironmentVariables(ctx context.Context, projectOrProductUID string, fleetUID string) ApiGetFleetEnvironmentVariablesRequest {
	return ApiGetFleetEnvironmentVariablesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *ProjectAPIService) GetFleetEnvironmentVariablesExecute(r ApiGetFleetEnvironmentVariablesRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetFleetEnvironmentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetsRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetFleetsRequest) Execute() (*GetDeviceFleets200Response, *http.Response, error) {
	return r.ApiService.GetFleetsExecute(r)
}

/*
GetFleets Method for GetFleets

Get Project Fleets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetFleetsRequest
*/
func (a *ProjectAPIService) GetFleets(ctx context.Context, projectOrProductUID string) ApiGetFleetsRequest {
	return ApiGetFleetsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceFleets200Response
func (a *ProjectAPIService) GetFleetsExecute(r ApiGetFleetsRequest) (*GetDeviceFleets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceFleets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetFleets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotefileSchemasRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetNotefileSchemasRequest) Execute() ([]NotefileSchema, *http.Response, error) {
	return r.ApiService.GetNotefileSchemasExecute(r)
}

/*
GetNotefileSchemas Get variable format for a notefile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetNotefileSchemasRequest
*/
func (a *ProjectAPIService) GetNotefileSchemas(ctx context.Context, projectOrProductUID string) ApiGetNotefileSchemasRequest {
	return ApiGetNotefileSchemasRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return []NotefileSchema
func (a *ProjectAPIService) GetNotefileSchemasExecute(r ApiGetNotefileSchemasRequest) ([]NotefileSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []NotefileSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetNotefileSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/schemas"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProductsRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetProductsRequest) Execute() (*GetProducts200Response, *http.Response, error) {
	return r.ApiService.GetProductsExecute(r)
}

/*
GetProducts Method for GetProducts

Get Products within a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetProductsRequest
*/
func (a *ProjectAPIService) GetProducts(ctx context.Context, projectOrProductUID string) ApiGetProductsRequest {
	return ApiGetProductsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetProducts200Response
func (a *ProjectAPIService) GetProductsExecute(r ApiGetProductsRequest) (*GetProducts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetProducts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetProjectRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.GetProjectExecute(r)
}

/*
GetProject Method for GetProject

Get a Project by ProjectUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetProjectRequest
*/
func (a *ProjectAPIService) GetProject(ctx context.Context, projectOrProductUID string) ApiGetProjectRequest {
	return ApiGetProjectRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectAPIService) GetProjectExecute(r ApiGetProjectRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectByProductRequest struct {
	ctx        context.Context
	ApiService *ProjectAPIService
	productUID string
}

func (r ApiGetProjectByProductRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.GetProjectByProductExecute(r)
}

/*
GetProjectByProduct Method for GetProjectByProduct

Get a Project by ProductUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param productUID
	@return ApiGetProjectByProductRequest
*/
func (a *ProjectAPIService) GetProjectByProduct(ctx context.Context, productUID string) ApiGetProjectByProductRequest {
	return ApiGetProjectByProductRequest{
		ApiService: a,
		ctx:        ctx,
		productUID: productUID,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectAPIService) GetProjectByProductExecute(r ApiGetProjectByProductRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectByProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/{productUID}/project"
	localVarPath = strings.Replace(localVarPath, "{"+"productUID"+"}", url.PathEscape(parameterValueToString(r.productUID, "productUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectEnvironmentHierarchyRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetProjectEnvironmentHierarchyRequest) Execute() (*EnvTreeJsonNode, *http.Response, error) {
	return r.ApiService.GetProjectEnvironmentHierarchyExecute(r)
}

/*
GetProjectEnvironmentHierarchy Get environment variable hierarchy for a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetProjectEnvironmentHierarchyRequest
*/
func (a *ProjectAPIService) GetProjectEnvironmentHierarchy(ctx context.Context, projectOrProductUID string) ApiGetProjectEnvironmentHierarchyRequest {
	return ApiGetProjectEnvironmentHierarchyRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return EnvTreeJsonNode
func (a *ProjectAPIService) GetProjectEnvironmentHierarchyExecute(r ApiGetProjectEnvironmentHierarchyRequest) (*EnvTreeJsonNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvTreeJsonNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectEnvironmentHierarchy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/environment_hierarchy"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectEnvironmentVariablesRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetProjectEnvironmentVariablesRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.GetProjectEnvironmentVariablesExecute(r)
}

/*
GetProjectEnvironmentVariables Method for GetProjectEnvironmentVariables

Get environment variables of a project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetProjectEnvironmentVariablesRequest
*/
func (a *ProjectAPIService) GetProjectEnvironmentVariables(ctx context.Context, projectOrProductUID string) ApiGetProjectEnvironmentVariablesRequest {
	return ApiGetProjectEnvironmentVariablesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *ProjectAPIService) GetProjectEnvironmentVariablesExecute(r ApiGetProjectEnvironmentVariablesRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectEnvironmentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectMembersRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
}

func (r ApiGetProjectMembersRequest) Execute() (*GetProjectMembers200Response, *http.Response, error) {
	return r.ApiService.GetProjectMembersExecute(r)
}

/*
GetProjectMembers Method for GetProjectMembers

Get Project Members

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetProjectMembersRequest
*/
func (a *ProjectAPIService) GetProjectMembers(ctx context.Context, projectOrProductUID string) ApiGetProjectMembersRequest {
	return ApiGetProjectMembersRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetProjectMembers200Response
func (a *ProjectAPIService) GetProjectMembersExecute(r ApiGetProjectMembersRequest) (*GetProjectMembers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetProjectMembers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectsRequest struct {
	ctx        context.Context
	ApiService *ProjectAPIService
}

func (r ApiGetProjectsRequest) Execute() (*GetProjects200Response, *http.Response, error) {
	return r.ApiService.GetProjectsExecute(r)
}

/*
GetProjects Method for GetProjects

Get Projects accessible by the api_key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetProjectsRequest
*/
func (a *ProjectAPIService) GetProjects(ctx context.Context) ApiGetProjectsRequest {
	return ApiGetProjectsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetProjects200Response
func (a *ProjectAPIService) GetProjectsExecute(r ApiGetProjectsRequest) (*GetProjects200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetProjects200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPerformDfuActionRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	firmwareType        string
	action              string
	deviceUID           *[]string
	tag                 *[]string
	serialNumber        *[]string
	fleetUID            *string
	notecardFirmware    *[]string
	location            *[]string
	hostFirmware        *[]string
	productUID          *[]string
	sku                 *[]string
	dfuActionRequest    *DfuActionRequest
}

// A Device UID.
func (r ApiPerformDfuActionRequest) DeviceUID(deviceUID []string) ApiPerformDfuActionRequest {
	r.deviceUID = &deviceUID
	return r
}

// Tag filter
func (r ApiPerformDfuActionRequest) Tag(tag []string) ApiPerformDfuActionRequest {
	r.tag = &tag
	return r
}

// Serial number filter
func (r ApiPerformDfuActionRequest) SerialNumber(serialNumber []string) ApiPerformDfuActionRequest {
	r.serialNumber = &serialNumber
	return r
}

func (r ApiPerformDfuActionRequest) FleetUID(fleetUID string) ApiPerformDfuActionRequest {
	r.fleetUID = &fleetUID
	return r
}

// Firmware version filter
func (r ApiPerformDfuActionRequest) NotecardFirmware(notecardFirmware []string) ApiPerformDfuActionRequest {
	r.notecardFirmware = &notecardFirmware
	return r
}

// Location filter
func (r ApiPerformDfuActionRequest) Location(location []string) ApiPerformDfuActionRequest {
	r.location = &location
	return r
}

// Host firmware filter
func (r ApiPerformDfuActionRequest) HostFirmware(hostFirmware []string) ApiPerformDfuActionRequest {
	r.hostFirmware = &hostFirmware
	return r
}

func (r ApiPerformDfuActionRequest) ProductUID(productUID []string) ApiPerformDfuActionRequest {
	r.productUID = &productUID
	return r
}

// SKU filter
func (r ApiPerformDfuActionRequest) Sku(sku []string) ApiPerformDfuActionRequest {
	r.sku = &sku
	return r
}

// Which firmware in the case of an update action
func (r ApiPerformDfuActionRequest) DfuActionRequest(dfuActionRequest DfuActionRequest) ApiPerformDfuActionRequest {
	r.dfuActionRequest = &dfuActionRequest
	return r
}

func (r ApiPerformDfuActionRequest) Execute() (*http.Response, error) {
	return r.ApiService.PerformDfuActionExecute(r)
}

/*
PerformDfuAction Method for PerformDfuAction

Update/cancel host or notecard firmware updates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param firmwareType
	@param action
	@return ApiPerformDfuActionRequest
*/
func (a *ProjectAPIService) PerformDfuAction(ctx context.Context, projectOrProductUID string, firmwareType string, action string) ApiPerformDfuActionRequest {
	return ApiPerformDfuActionRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		firmwareType:        firmwareType,
		action:              action,
	}
}

// Execute executes the request
func (a *ProjectAPIService) PerformDfuActionExecute(r ApiPerformDfuActionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.PerformDfuAction")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/dfu/{firmwareType}/{action}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"firmwareType"+"}", url.PathEscape(parameterValueToString(r.firmwareType, "firmwareType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"action"+"}", url.PathEscape(parameterValueToString(r.action, "action")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", r.fleetUID, "form", "")
	}
	if r.notecardFirmware != nil {
		t := *r.notecardFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", t, "form", "multi")
		}
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.hostFirmware != nil {
		t := *r.hostFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", t, "form", "multi")
		}
	}
	if r.productUID != nil {
		t := *r.productUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", t, "form", "multi")
		}
	}
	if r.sku != nil {
		t := *r.sku
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sku", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sku", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dfuActionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetFleetEnvironmentVariablesRequest struct {
	ctx                  context.Context
	ApiService           *ProjectAPIService
	projectOrProductUID  string
	fleetUID             string
	environmentVariables *EnvironmentVariables
}

// Environment variables to be added to the fleet
func (r ApiSetFleetEnvironmentVariablesRequest) EnvironmentVariables(environmentVariables EnvironmentVariables) ApiSetFleetEnvironmentVariablesRequest {
	r.environmentVariables = &environmentVariables
	return r
}

func (r ApiSetFleetEnvironmentVariablesRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.SetFleetEnvironmentVariablesExecute(r)
}

/*
SetFleetEnvironmentVariables Method for SetFleetEnvironmentVariables

Set environment variables of a fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiSetFleetEnvironmentVariablesRequest
*/
func (a *ProjectAPIService) SetFleetEnvironmentVariables(ctx context.Context, projectOrProductUID string, fleetUID string) ApiSetFleetEnvironmentVariablesRequest {
	return ApiSetFleetEnvironmentVariablesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *ProjectAPIService) SetFleetEnvironmentVariablesExecute(r ApiSetFleetEnvironmentVariablesRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.SetFleetEnvironmentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentVariables == nil {
		return localVarReturnValue, nil, reportError("environmentVariables is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environmentVariables
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetGlobalEventTransformationRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	body                *map[string]interface{}
}

// JSONata expression which will be applied to each event before it is persisted and routed
func (r ApiSetGlobalEventTransformationRequest) Body(body map[string]interface{}) ApiSetGlobalEventTransformationRequest {
	r.body = &body
	return r
}

func (r ApiSetGlobalEventTransformationRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetGlobalEventTransformationExecute(r)
}

/*
SetGlobalEventTransformation Method for SetGlobalEventTransformation

Set the project-level event JSONata transformation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiSetGlobalEventTransformationRequest
*/
func (a *ProjectAPIService) SetGlobalEventTransformation(ctx context.Context, projectOrProductUID string) ApiSetGlobalEventTransformationRequest {
	return ApiSetGlobalEventTransformationRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
func (a *ProjectAPIService) SetGlobalEventTransformationExecute(r ApiSetGlobalEventTransformationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.SetGlobalEventTransformation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/global-transformation"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetProjectEnvironmentVariablesRequest struct {
	ctx                  context.Context
	ApiService           *ProjectAPIService
	projectOrProductUID  string
	environmentVariables *EnvironmentVariables
}

func (r ApiSetProjectEnvironmentVariablesRequest) EnvironmentVariables(environmentVariables EnvironmentVariables) ApiSetProjectEnvironmentVariablesRequest {
	r.environmentVariables = &environmentVariables
	return r
}

func (r ApiSetProjectEnvironmentVariablesRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.SetProjectEnvironmentVariablesExecute(r)
}

/*
SetProjectEnvironmentVariables Method for SetProjectEnvironmentVariables

Set environment variables of a project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiSetProjectEnvironmentVariablesRequest
*/
func (a *ProjectAPIService) SetProjectEnvironmentVariables(ctx context.Context, projectOrProductUID string) ApiSetProjectEnvironmentVariablesRequest {
	return ApiSetProjectEnvironmentVariablesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *ProjectAPIService) SetProjectEnvironmentVariablesExecute(r ApiSetProjectEnvironmentVariablesRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.SetProjectEnvironmentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environmentVariables
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFleetRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	fleetUID            string
	updateFleetRequest  *UpdateFleetRequest
}

// Fleet details to update
func (r ApiUpdateFleetRequest) UpdateFleetRequest(updateFleetRequest UpdateFleetRequest) ApiUpdateFleetRequest {
	r.updateFleetRequest = &updateFleetRequest
	return r
}

func (r ApiUpdateFleetRequest) Execute() (*Fleet, *http.Response, error) {
	return r.ApiService.UpdateFleetExecute(r)
}

/*
UpdateFleet Method for UpdateFleet

Update Fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiUpdateFleetRequest
*/
func (a *ProjectAPIService) UpdateFleet(ctx context.Context, projectOrProductUID string, fleetUID string) ApiUpdateFleetRequest {
	return ApiUpdateFleetRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return Fleet
func (a *ProjectAPIService) UpdateFleetExecute(r ApiUpdateFleetRequest) (*Fleet, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Fleet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.UpdateFleet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFleetRequest == nil {
		return localVarReturnValue, nil, reportError("updateFleetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFleetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFirmwareRequest struct {
	ctx                 context.Context
	ApiService          *ProjectAPIService
	projectOrProductUID string
	firmwareType        string
	filename            string
	body                *os.File
	version             *string
	notes               *string
}

// contents of the firmware binary
func (r ApiUploadFirmwareRequest) Body(body *os.File) ApiUploadFirmwareRequest {
	r.body = body
	return r
}

// Firmware version (optional). If not provided, the version will be extracted from firmware binary if available, otherwise left empty
func (r ApiUploadFirmwareRequest) Version(version string) ApiUploadFirmwareRequest {
	r.version = &version
	return r
}

// Optional notes describing what&#39;s different about this firmware version
func (r ApiUploadFirmwareRequest) Notes(notes string) ApiUploadFirmwareRequest {
	r.notes = &notes
	return r
}

func (r ApiUploadFirmwareRequest) Execute() (*FirmwareInfo, *http.Response, error) {
	return r.ApiService.UploadFirmwareExecute(r)
}

/*
UploadFirmware Method for UploadFirmware

Upload firmware binary

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param firmwareType
	@param filename
	@return ApiUploadFirmwareRequest
*/
func (a *ProjectAPIService) UploadFirmware(ctx context.Context, projectOrProductUID string, firmwareType string, filename string) ApiUploadFirmwareRequest {
	return ApiUploadFirmwareRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		firmwareType:        firmwareType,
		filename:            filename,
	}
}

// Execute executes the request
//
//	@return FirmwareInfo
func (a *ProjectAPIService) UploadFirmwareExecute(r ApiUploadFirmwareRequest) (*FirmwareInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FirmwareInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.UploadFirmware")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/firmware/{firmwareType}/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"firmwareType"+"}", url.PathEscape(parameterValueToString(r.firmwareType, "firmwareType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.notes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notes", r.notes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
