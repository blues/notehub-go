/*
Notehub API

The OpenAPI definition for the Notehub.io API.

API version: 1.2.0
Contact: engineering@blues.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package notehub

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// DeviceAPIService DeviceAPI service
type DeviceAPIService service

type ApiAddDbNoteRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	notefileID          string
	noteID              string
	note                *Note
}

// Body or payload of note to be added to the device
func (r ApiAddDbNoteRequest) Note(note Note) ApiAddDbNoteRequest {
	r.note = &note
	return r
}

func (r ApiAddDbNoteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddDbNoteExecute(r)
}

/*
AddDbNote Method for AddDbNote

Add a Note to a .db notefile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param notefileID
	@param noteID
	@return ApiAddDbNoteRequest
*/
func (a *DeviceAPIService) AddDbNote(ctx context.Context, projectOrProductUID string, deviceUID string, notefileID string, noteID string) ApiAddDbNoteRequest {
	return ApiAddDbNoteRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		notefileID:          notefileID,
		noteID:              noteID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) AddDbNoteExecute(r ApiAddDbNoteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.AddDbNote")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/notes/{notefileID}/{noteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notefileID"+"}", url.PathEscape(parameterValueToString(r.notefileID, "notefileID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"noteID"+"}", url.PathEscape(parameterValueToString(r.noteID, "noteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.note == nil {
		return nil, reportError("note is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.note
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddQiNoteRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	notefileID          string
	note                *Note
}

// Body or payload of note to be added to the device
func (r ApiAddQiNoteRequest) Note(note Note) ApiAddQiNoteRequest {
	r.note = &note
	return r
}

func (r ApiAddQiNoteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddQiNoteExecute(r)
}

/*
AddQiNote Method for AddQiNote

Adds a Note to a Notefile, creating the Notefile if it doesn't yet exist.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param notefileID
	@return ApiAddQiNoteRequest
*/
func (a *DeviceAPIService) AddQiNote(ctx context.Context, projectOrProductUID string, deviceUID string, notefileID string) ApiAddQiNoteRequest {
	return ApiAddQiNoteRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		notefileID:          notefileID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) AddQiNoteExecute(r ApiAddQiNoteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.AddQiNote")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/notes/{notefileID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notefileID"+"}", url.PathEscape(parameterValueToString(r.notefileID, "notefileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.note == nil {
		return nil, reportError("note is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.note
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDbNoteRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	notefileID          string
	noteID              string
}

func (r ApiDeleteDbNoteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDbNoteExecute(r)
}

/*
DeleteDbNote Method for DeleteDbNote

Delete a note from a .db notefile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param notefileID
	@param noteID
	@return ApiDeleteDbNoteRequest
*/
func (a *DeviceAPIService) DeleteDbNote(ctx context.Context, projectOrProductUID string, deviceUID string, notefileID string, noteID string) ApiDeleteDbNoteRequest {
	return ApiDeleteDbNoteRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		notefileID:          notefileID,
		noteID:              noteID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) DeleteDbNoteExecute(r ApiDeleteDbNoteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.DeleteDbNote")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/notes/{notefileID}/{noteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notefileID"+"}", url.PathEscape(parameterValueToString(r.notefileID, "notefileID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"noteID"+"}", url.PathEscape(parameterValueToString(r.noteID, "noteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDeviceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	purge               *bool
}

func (r ApiDeleteDeviceRequest) Purge(purge bool) ApiDeleteDeviceRequest {
	r.purge = &purge
	return r
}

func (r ApiDeleteDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeviceExecute(r)
}

/*
DeleteDevice Method for DeleteDevice

Delete Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiDeleteDeviceRequest
*/
func (a *DeviceAPIService) DeleteDevice(ctx context.Context, projectOrProductUID string, deviceUID string) ApiDeleteDeviceRequest {
	return ApiDeleteDeviceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) DeleteDeviceExecute(r ApiDeleteDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.DeleteDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.purge == nil {
		return nil, reportError("purge is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDeviceEnvironmentVariableRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	key                 string
}

func (r ApiDeleteDeviceEnvironmentVariableRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.DeleteDeviceEnvironmentVariableExecute(r)
}

/*
DeleteDeviceEnvironmentVariable Method for DeleteDeviceEnvironmentVariable

Delete environment variable of a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param key The environment variable key to delete.
	@return ApiDeleteDeviceEnvironmentVariableRequest
*/
func (a *DeviceAPIService) DeleteDeviceEnvironmentVariable(ctx context.Context, projectOrProductUID string, deviceUID string, key string) ApiDeleteDeviceEnvironmentVariableRequest {
	return ApiDeleteDeviceEnvironmentVariableRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		key:                 key,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *DeviceAPIService) DeleteDeviceEnvironmentVariableExecute(r ApiDeleteDeviceEnvironmentVariableRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.DeleteDeviceEnvironmentVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/environment_variables/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNotefilesRequest struct {
	ctx                    context.Context
	ApiService             *DeviceAPIService
	projectOrProductUID    string
	deviceUID              string
	deleteNotefilesRequest *DeleteNotefilesRequest
}

func (r ApiDeleteNotefilesRequest) DeleteNotefilesRequest(deleteNotefilesRequest DeleteNotefilesRequest) ApiDeleteNotefilesRequest {
	r.deleteNotefilesRequest = &deleteNotefilesRequest
	return r
}

func (r ApiDeleteNotefilesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNotefilesExecute(r)
}

/*
DeleteNotefiles Method for DeleteNotefiles

Deletes Notefiles and the Notes they contain.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiDeleteNotefilesRequest
*/
func (a *DeviceAPIService) DeleteNotefiles(ctx context.Context, projectOrProductUID string, deviceUID string) ApiDeleteNotefilesRequest {
	return ApiDeleteNotefilesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) DeleteNotefilesExecute(r ApiDeleteNotefilesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.DeleteNotefiles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteNotefilesRequest == nil {
		return nil, reportError("deleteNotefilesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteNotefilesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableDeviceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiDisableDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableDeviceExecute(r)
}

/*
DisableDevice Method for DisableDevice

Disable Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiDisableDeviceRequest
*/
func (a *DeviceAPIService) DisableDevice(ctx context.Context, projectOrProductUID string, deviceUID string) ApiDisableDeviceRequest {
	return ApiDisableDeviceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) DisableDeviceExecute(r ApiDisableDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.DisableDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableDeviceConnectivityAssuranceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiDisableDeviceConnectivityAssuranceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableDeviceConnectivityAssuranceExecute(r)
}

/*
DisableDeviceConnectivityAssurance Method for DisableDeviceConnectivityAssurance

Disable Connectivity Assurance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiDisableDeviceConnectivityAssuranceRequest
*/
func (a *DeviceAPIService) DisableDeviceConnectivityAssurance(ctx context.Context, projectOrProductUID string, deviceUID string) ApiDisableDeviceConnectivityAssuranceRequest {
	return ApiDisableDeviceConnectivityAssuranceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) DisableDeviceConnectivityAssuranceExecute(r ApiDisableDeviceConnectivityAssuranceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.DisableDeviceConnectivityAssurance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/disable-connectivity-assurance"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableDeviceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiEnableDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableDeviceExecute(r)
}

/*
EnableDevice Method for EnableDevice

Enable Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiEnableDeviceRequest
*/
func (a *DeviceAPIService) EnableDevice(ctx context.Context, projectOrProductUID string, deviceUID string) ApiEnableDeviceRequest {
	return ApiEnableDeviceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) EnableDeviceExecute(r ApiEnableDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.EnableDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableDeviceConnectivityAssuranceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiEnableDeviceConnectivityAssuranceRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableDeviceConnectivityAssuranceExecute(r)
}

/*
EnableDeviceConnectivityAssurance Method for EnableDeviceConnectivityAssurance

Enable Connectivity Assurance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiEnableDeviceConnectivityAssuranceRequest
*/
func (a *DeviceAPIService) EnableDeviceConnectivityAssurance(ctx context.Context, projectOrProductUID string, deviceUID string) ApiEnableDeviceConnectivityAssuranceRequest {
	return ApiEnableDeviceConnectivityAssuranceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) EnableDeviceConnectivityAssuranceExecute(r ApiEnableDeviceConnectivityAssuranceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.EnableDeviceConnectivityAssurance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/enable-connectivity-assurance"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDbNoteRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	notefileID          string
	noteID              string
	delete              *bool
	deleted             *bool
}

// Whether to delete the note from the DB notefile
func (r ApiGetDbNoteRequest) Delete(delete bool) ApiGetDbNoteRequest {
	r.delete = &delete
	return r
}

// Whether to return deleted notes
func (r ApiGetDbNoteRequest) Deleted(deleted bool) ApiGetDbNoteRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetDbNoteRequest) Execute() (*GetDbNote200Response, *http.Response, error) {
	return r.ApiService.GetDbNoteExecute(r)
}

/*
GetDbNote Method for GetDbNote

Get a note from a .db notefile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param notefileID
	@param noteID
	@return ApiGetDbNoteRequest
*/
func (a *DeviceAPIService) GetDbNote(ctx context.Context, projectOrProductUID string, deviceUID string, notefileID string, noteID string) ApiGetDbNoteRequest {
	return ApiGetDbNoteRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		notefileID:          notefileID,
		noteID:              noteID,
	}
}

// Execute executes the request
//
//	@return GetDbNote200Response
func (a *DeviceAPIService) GetDbNoteExecute(r ApiGetDbNoteRequest) (*GetDbNote200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDbNote200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDbNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/notes/{notefileID}/{noteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notefileID"+"}", url.PathEscape(parameterValueToString(r.notefileID, "notefileID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"noteID"+"}", url.PathEscape(parameterValueToString(r.noteID, "noteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.delete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete", r.delete, "form", "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDeviceRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.GetDeviceExecute(r)
}

/*
GetDevice Method for GetDevice

Get Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceRequest
*/
func (a *DeviceAPIService) GetDevice(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceRequest {
	return ApiGetDeviceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return Device
func (a *DeviceAPIService) GetDeviceExecute(r ApiGetDeviceRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceEnvironmentHierarchyRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDeviceEnvironmentHierarchyRequest) Execute() (*EnvTreeJsonNode, *http.Response, error) {
	return r.ApiService.GetDeviceEnvironmentHierarchyExecute(r)
}

/*
GetDeviceEnvironmentHierarchy Get environment variable hierarchy for a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceEnvironmentHierarchyRequest
*/
func (a *DeviceAPIService) GetDeviceEnvironmentHierarchy(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceEnvironmentHierarchyRequest {
	return ApiGetDeviceEnvironmentHierarchyRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return EnvTreeJsonNode
func (a *DeviceAPIService) GetDeviceEnvironmentHierarchyExecute(r ApiGetDeviceEnvironmentHierarchyRequest) (*EnvTreeJsonNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvTreeJsonNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDeviceEnvironmentHierarchy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/environment_hierarchy"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceEnvironmentVariablesRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDeviceEnvironmentVariablesRequest) Execute() (*GetDeviceEnvironmentVariablesByPin200Response, *http.Response, error) {
	return r.ApiService.GetDeviceEnvironmentVariablesExecute(r)
}

/*
GetDeviceEnvironmentVariables Method for GetDeviceEnvironmentVariables

Get environment variables of a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceEnvironmentVariablesRequest
*/
func (a *DeviceAPIService) GetDeviceEnvironmentVariables(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceEnvironmentVariablesRequest {
	return ApiGetDeviceEnvironmentVariablesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceEnvironmentVariablesByPin200Response
func (a *DeviceAPIService) GetDeviceEnvironmentVariablesExecute(r ApiGetDeviceEnvironmentVariablesRequest) (*GetDeviceEnvironmentVariablesByPin200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceEnvironmentVariablesByPin200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDeviceEnvironmentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceEnvironmentVariablesByPinRequest struct {
	ctx        context.Context
	ApiService *DeviceAPIService
	productUID string
	deviceUID  string
}

func (r ApiGetDeviceEnvironmentVariablesByPinRequest) Execute() (*GetDeviceEnvironmentVariablesByPin200Response, *http.Response, error) {
	return r.ApiService.GetDeviceEnvironmentVariablesByPinExecute(r)
}

/*
GetDeviceEnvironmentVariablesByPin Method for GetDeviceEnvironmentVariablesByPin

Get environment variables of a device with device pin authorization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param productUID
	@param deviceUID
	@return ApiGetDeviceEnvironmentVariablesByPinRequest
*/
func (a *DeviceAPIService) GetDeviceEnvironmentVariablesByPin(ctx context.Context, productUID string, deviceUID string) ApiGetDeviceEnvironmentVariablesByPinRequest {
	return ApiGetDeviceEnvironmentVariablesByPinRequest{
		ApiService: a,
		ctx:        ctx,
		productUID: productUID,
		deviceUID:  deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceEnvironmentVariablesByPin200Response
func (a *DeviceAPIService) GetDeviceEnvironmentVariablesByPinExecute(r ApiGetDeviceEnvironmentVariablesByPinRequest) (*GetDeviceEnvironmentVariablesByPin200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceEnvironmentVariablesByPin200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDeviceEnvironmentVariablesByPin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/{productUID}/devices/{deviceUID}/environment_variables_with_pin"
	localVarPath = strings.Replace(localVarPath, "{"+"productUID"+"}", url.PathEscape(parameterValueToString(r.productUID, "productUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["pin"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceHealthLogRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	startDate           *int32
	endDate             *int32
	logType             *[]string
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetDeviceHealthLogRequest) StartDate(startDate int32) ApiGetDeviceHealthLogRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetDeviceHealthLogRequest) EndDate(endDate int32) ApiGetDeviceHealthLogRequest {
	r.endDate = &endDate
	return r
}

// Return only specified log types
func (r ApiGetDeviceHealthLogRequest) LogType(logType []string) ApiGetDeviceHealthLogRequest {
	r.logType = &logType
	return r
}

func (r ApiGetDeviceHealthLogRequest) Execute() (*GetDeviceHealthLog200Response, *http.Response, error) {
	return r.ApiService.GetDeviceHealthLogExecute(r)
}

/*
GetDeviceHealthLog Method for GetDeviceHealthLog

Get Device Health Log

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceHealthLogRequest
*/
func (a *DeviceAPIService) GetDeviceHealthLog(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceHealthLogRequest {
	return ApiGetDeviceHealthLogRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceHealthLog200Response
func (a *DeviceAPIService) GetDeviceHealthLogExecute(r ApiGetDeviceHealthLogRequest) (*GetDeviceHealthLog200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceHealthLog200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDeviceHealthLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/health-log"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.logType != nil {
		t := *r.logType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "log_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "log_type", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceLatestEventsRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDeviceLatestEventsRequest) Execute() (*GetDeviceLatestEvents200Response, *http.Response, error) {
	return r.ApiService.GetDeviceLatestEventsExecute(r)
}

/*
GetDeviceLatestEvents Method for GetDeviceLatestEvents

Get Device Latest Events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceLatestEventsRequest
*/
func (a *DeviceAPIService) GetDeviceLatestEvents(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceLatestEventsRequest {
	return ApiGetDeviceLatestEventsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceLatestEvents200Response
func (a *DeviceAPIService) GetDeviceLatestEventsExecute(r ApiGetDeviceLatestEventsRequest) (*GetDeviceLatestEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceLatestEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDeviceLatestEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicePlansRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDevicePlansRequest) Execute() (*GetDevicePlans200Response, *http.Response, error) {
	return r.ApiService.GetDevicePlansExecute(r)
}

/*
GetDevicePlans Method for GetDevicePlans

Get Data Plans associated with the device, this include the primary sim, any external sim, as well as any satellite connections.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDevicePlansRequest
*/
func (a *DeviceAPIService) GetDevicePlans(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDevicePlansRequest {
	return ApiGetDevicePlansRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDevicePlans200Response
func (a *DeviceAPIService) GetDevicePlansExecute(r ApiGetDevicePlansRequest) (*GetDevicePlans200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDevicePlans200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDevicePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/plans"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicePublicKeyRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiGetDevicePublicKeyRequest) Execute() (*GetDevicePublicKey200Response, *http.Response, error) {
	return r.ApiService.GetDevicePublicKeyExecute(r)
}

/*
GetDevicePublicKey Method for GetDevicePublicKey

Get Device Public Key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDevicePublicKeyRequest
*/
func (a *DeviceAPIService) GetDevicePublicKey(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDevicePublicKeyRequest {
	return ApiGetDevicePublicKeyRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDevicePublicKey200Response
func (a *DeviceAPIService) GetDevicePublicKeyExecute(r ApiGetDevicePublicKeyRequest) (*GetDevicePublicKey200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDevicePublicKey200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDevicePublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/public-key"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicePublicKeysRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	pageSize            *int32
	pageNum             *int32
}

func (r ApiGetDevicePublicKeysRequest) PageSize(pageSize int32) ApiGetDevicePublicKeysRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDevicePublicKeysRequest) PageNum(pageNum int32) ApiGetDevicePublicKeysRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiGetDevicePublicKeysRequest) Execute() (*GetDevicePublicKeys200Response, *http.Response, error) {
	return r.ApiService.GetDevicePublicKeysExecute(r)
}

/*
GetDevicePublicKeys Method for GetDevicePublicKeys

Get Device Public Keys of a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetDevicePublicKeysRequest
*/
func (a *DeviceAPIService) GetDevicePublicKeys(ctx context.Context, projectOrProductUID string) ApiGetDevicePublicKeysRequest {
	return ApiGetDevicePublicKeysRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetDevicePublicKeys200Response
func (a *DeviceAPIService) GetDevicePublicKeysExecute(r ApiGetDevicePublicKeysRequest) (*GetDevicePublicKeys200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDevicePublicKeys200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDevicePublicKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/public-keys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceSessionsRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	pageSize            *int32
	pageNum             *int32
	startDate           *int32
	endDate             *int32
}

func (r ApiGetDeviceSessionsRequest) PageSize(pageSize int32) ApiGetDeviceSessionsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDeviceSessionsRequest) PageNum(pageNum int32) ApiGetDeviceSessionsRequest {
	r.pageNum = &pageNum
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetDeviceSessionsRequest) StartDate(startDate int32) ApiGetDeviceSessionsRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetDeviceSessionsRequest) EndDate(endDate int32) ApiGetDeviceSessionsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetDeviceSessionsRequest) Execute() (*GetDeviceSessions200Response, *http.Response, error) {
	return r.ApiService.GetDeviceSessionsExecute(r)
}

/*
GetDeviceSessions Method for GetDeviceSessions

Get Device Sessions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiGetDeviceSessionsRequest
*/
func (a *DeviceAPIService) GetDeviceSessions(ctx context.Context, projectOrProductUID string, deviceUID string) ApiGetDeviceSessionsRequest {
	return ApiGetDeviceSessionsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return GetDeviceSessions200Response
func (a *DeviceAPIService) GetDeviceSessionsExecute(r ApiGetDeviceSessionsRequest) (*GetDeviceSessions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDeviceSessions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDeviceSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	pageSize            *int32
	pageNum             *int32
	deviceUID           *[]string
	tag                 *[]string
	serialNumber        *[]string
	fleetUID            *[]string
	notecardFirmware    *[]string
	location            *[]string
	hostFirmware        *[]string
	productUID          *[]string
	sku                 *[]string
}

func (r ApiGetDevicesRequest) PageSize(pageSize int32) ApiGetDevicesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDevicesRequest) PageNum(pageNum int32) ApiGetDevicesRequest {
	r.pageNum = &pageNum
	return r
}

// A Device UID.
func (r ApiGetDevicesRequest) DeviceUID(deviceUID []string) ApiGetDevicesRequest {
	r.deviceUID = &deviceUID
	return r
}

// Tag filter
func (r ApiGetDevicesRequest) Tag(tag []string) ApiGetDevicesRequest {
	r.tag = &tag
	return r
}

// Serial number filter
func (r ApiGetDevicesRequest) SerialNumber(serialNumber []string) ApiGetDevicesRequest {
	r.serialNumber = &serialNumber
	return r
}

func (r ApiGetDevicesRequest) FleetUID(fleetUID []string) ApiGetDevicesRequest {
	r.fleetUID = &fleetUID
	return r
}

// Firmware version filter
func (r ApiGetDevicesRequest) NotecardFirmware(notecardFirmware []string) ApiGetDevicesRequest {
	r.notecardFirmware = &notecardFirmware
	return r
}

// Location filter
func (r ApiGetDevicesRequest) Location(location []string) ApiGetDevicesRequest {
	r.location = &location
	return r
}

// Host firmware filter
func (r ApiGetDevicesRequest) HostFirmware(hostFirmware []string) ApiGetDevicesRequest {
	r.hostFirmware = &hostFirmware
	return r
}

func (r ApiGetDevicesRequest) ProductUID(productUID []string) ApiGetDevicesRequest {
	r.productUID = &productUID
	return r
}

// SKU filter
func (r ApiGetDevicesRequest) Sku(sku []string) ApiGetDevicesRequest {
	r.sku = &sku
	return r
}

func (r ApiGetDevicesRequest) Execute() (*GetDevices200Response, *http.Response, error) {
	return r.ApiService.GetDevicesExecute(r)
}

/*
GetDevices Method for GetDevices

Get Devices of a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetDevicesRequest
*/
func (a *DeviceAPIService) GetDevices(ctx context.Context, projectOrProductUID string) ApiGetDevicesRequest {
	return ApiGetDevicesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetDevices200Response
func (a *DeviceAPIService) GetDevicesExecute(r ApiGetDevicesRequest) (*GetDevices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDevices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		t := *r.fleetUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", t, "form", "multi")
		}
	}
	if r.notecardFirmware != nil {
		t := *r.notecardFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", t, "form", "multi")
		}
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.hostFirmware != nil {
		t := *r.hostFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", t, "form", "multi")
		}
	}
	if r.productUID != nil {
		t := *r.productUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", t, "form", "multi")
		}
	}
	if r.sku != nil {
		t := *r.sku
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sku", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sku", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetDevicesRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	fleetUID            string
	pageSize            *int32
	pageNum             *int32
	deviceUID           *[]string
	tag                 *[]string
	serialNumber        *[]string
	notecardFirmware    *[]string
	location            *[]string
	hostFirmware        *[]string
	productUID          *[]string
	sku                 *[]string
}

func (r ApiGetFleetDevicesRequest) PageSize(pageSize int32) ApiGetFleetDevicesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetFleetDevicesRequest) PageNum(pageNum int32) ApiGetFleetDevicesRequest {
	r.pageNum = &pageNum
	return r
}

// A Device UID.
func (r ApiGetFleetDevicesRequest) DeviceUID(deviceUID []string) ApiGetFleetDevicesRequest {
	r.deviceUID = &deviceUID
	return r
}

// Tag filter
func (r ApiGetFleetDevicesRequest) Tag(tag []string) ApiGetFleetDevicesRequest {
	r.tag = &tag
	return r
}

// Serial number filter
func (r ApiGetFleetDevicesRequest) SerialNumber(serialNumber []string) ApiGetFleetDevicesRequest {
	r.serialNumber = &serialNumber
	return r
}

// Firmware version filter
func (r ApiGetFleetDevicesRequest) NotecardFirmware(notecardFirmware []string) ApiGetFleetDevicesRequest {
	r.notecardFirmware = &notecardFirmware
	return r
}

// Location filter
func (r ApiGetFleetDevicesRequest) Location(location []string) ApiGetFleetDevicesRequest {
	r.location = &location
	return r
}

// Host firmware filter
func (r ApiGetFleetDevicesRequest) HostFirmware(hostFirmware []string) ApiGetFleetDevicesRequest {
	r.hostFirmware = &hostFirmware
	return r
}

func (r ApiGetFleetDevicesRequest) ProductUID(productUID []string) ApiGetFleetDevicesRequest {
	r.productUID = &productUID
	return r
}

// SKU filter
func (r ApiGetFleetDevicesRequest) Sku(sku []string) ApiGetFleetDevicesRequest {
	r.sku = &sku
	return r
}

func (r ApiGetFleetDevicesRequest) Execute() (*GetDevices200Response, *http.Response, error) {
	return r.ApiService.GetFleetDevicesExecute(r)
}

/*
GetFleetDevices Method for GetFleetDevices

Get Devices of a Fleet within a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiGetFleetDevicesRequest
*/
func (a *DeviceAPIService) GetFleetDevices(ctx context.Context, projectOrProductUID string, fleetUID string) ApiGetFleetDevicesRequest {
	return ApiGetFleetDevicesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return GetDevices200Response
func (a *DeviceAPIService) GetFleetDevicesExecute(r ApiGetFleetDevicesRequest) (*GetDevices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDevices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetFleetDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.notecardFirmware != nil {
		t := *r.notecardFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notecardFirmware", t, "form", "multi")
		}
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.hostFirmware != nil {
		t := *r.hostFirmware
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hostFirmware", t, "form", "multi")
		}
	}
	if r.productUID != nil {
		t := *r.productUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productUID", t, "form", "multi")
		}
	}
	if r.sku != nil {
		t := *r.sku
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sku", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sku", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotefileRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	notefileID          string
	tracker             *string
	max                 *int32
	start               *bool
	stop                *bool
	deleted             *bool
	delete              *bool
}

// The change tracker ID.
func (r ApiGetNotefileRequest) Tracker(tracker string) ApiGetNotefileRequest {
	r.tracker = &tracker
	return r
}

// The maximum number of Notes to return in the request.
func (r ApiGetNotefileRequest) Max(max int32) ApiGetNotefileRequest {
	r.max = &max
	return r
}

// true to reset the tracker to the beginning.
func (r ApiGetNotefileRequest) Start(start bool) ApiGetNotefileRequest {
	r.start = &start
	return r
}

// true to delete the tracker.
func (r ApiGetNotefileRequest) Stop(stop bool) ApiGetNotefileRequest {
	r.stop = &stop
	return r
}

// true to return deleted notes.
func (r ApiGetNotefileRequest) Deleted(deleted bool) ApiGetNotefileRequest {
	r.deleted = &deleted
	return r
}

// true to delete the notes returned by the request.
func (r ApiGetNotefileRequest) Delete(delete bool) ApiGetNotefileRequest {
	r.delete = &delete
	return r
}

func (r ApiGetNotefileRequest) Execute() (*GetNotefile200Response, *http.Response, error) {
	return r.ApiService.GetNotefileExecute(r)
}

/*
GetNotefile Method for GetNotefile

For .qi files, returns the queued up notes.  For .db files, returns all notes in the notefile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param notefileID
	@return ApiGetNotefileRequest
*/
func (a *DeviceAPIService) GetNotefile(ctx context.Context, projectOrProductUID string, deviceUID string, notefileID string) ApiGetNotefileRequest {
	return ApiGetNotefileRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		notefileID:          notefileID,
	}
}

// Execute executes the request
//
//	@return GetNotefile200Response
func (a *DeviceAPIService) GetNotefileExecute(r ApiGetNotefileRequest) (*GetNotefile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetNotefile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.GetNotefile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/notes/{notefileID}/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notefileID"+"}", url.PathEscape(parameterValueToString(r.notefileID, "notefileID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tracker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tracker", r.tracker, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.stop != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stop", r.stop, "form", "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "form", "")
	}
	if r.delete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete", r.delete, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNotefilesRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	tracker             *string
	files               *[]string
}

// The change tracker ID.
func (r ApiListNotefilesRequest) Tracker(tracker string) ApiListNotefilesRequest {
	r.tracker = &tracker
	return r
}

// One or more files to obtain change information from.
func (r ApiListNotefilesRequest) Files(files []string) ApiListNotefilesRequest {
	r.files = &files
	return r
}

func (r ApiListNotefilesRequest) Execute() (*ListNotefiles200Response, *http.Response, error) {
	return r.ApiService.ListNotefilesExecute(r)
}

/*
ListNotefiles Method for ListNotefiles

Lists .qi and .db files for the device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiListNotefilesRequest
*/
func (a *DeviceAPIService) ListNotefiles(ctx context.Context, projectOrProductUID string, deviceUID string) ApiListNotefilesRequest {
	return ApiListNotefilesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return ListNotefiles200Response
func (a *DeviceAPIService) ListNotefilesExecute(r ApiListNotefilesRequest) (*ListNotefiles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListNotefiles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.ListNotefiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/files/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tracker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tracker", r.tracker, "form", "")
	}
	if r.files != nil {
		t := *r.files
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "files", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "files", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPendingNotefilesRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
}

func (r ApiListPendingNotefilesRequest) Execute() (*ListPendingNotefiles200Response, *http.Response, error) {
	return r.ApiService.ListPendingNotefilesExecute(r)
}

/*
ListPendingNotefiles Method for ListPendingNotefiles

Lists .qi and .db files that are pending sync to the Notecard

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiListPendingNotefilesRequest
*/
func (a *DeviceAPIService) ListPendingNotefiles(ctx context.Context, projectOrProductUID string, deviceUID string) ApiListPendingNotefilesRequest {
	return ApiListPendingNotefilesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return ListPendingNotefiles200Response
func (a *DeviceAPIService) ListPendingNotefilesExecute(r ApiListPendingNotefilesRequest) (*ListPendingNotefiles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPendingNotefiles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.ListPendingNotefiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/files/changes/pending"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProvisionDeviceRequest struct {
	ctx                    context.Context
	ApiService             *DeviceAPIService
	projectOrProductUID    string
	deviceUID              string
	provisionDeviceRequest *ProvisionDeviceRequest
}

// Provision a device to a specific ProductUID
func (r ApiProvisionDeviceRequest) ProvisionDeviceRequest(provisionDeviceRequest ProvisionDeviceRequest) ApiProvisionDeviceRequest {
	r.provisionDeviceRequest = &provisionDeviceRequest
	return r
}

func (r ApiProvisionDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProvisionDeviceExecute(r)
}

/*
ProvisionDevice Method for ProvisionDevice

Provision Device for a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiProvisionDeviceRequest
*/
func (a *DeviceAPIService) ProvisionDevice(ctx context.Context, projectOrProductUID string, deviceUID string) ApiProvisionDeviceRequest {
	return ApiProvisionDeviceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DeviceAPIService) ProvisionDeviceExecute(r ApiProvisionDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.ProvisionDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/provision"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.provisionDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("provisionDeviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.provisionDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDeviceEnvironmentVariablesRequest struct {
	ctx                  context.Context
	ApiService           *DeviceAPIService
	projectOrProductUID  string
	deviceUID            string
	environmentVariables *EnvironmentVariables
}

// Environment variables to be added to the device
func (r ApiSetDeviceEnvironmentVariablesRequest) EnvironmentVariables(environmentVariables EnvironmentVariables) ApiSetDeviceEnvironmentVariablesRequest {
	r.environmentVariables = &environmentVariables
	return r
}

func (r ApiSetDeviceEnvironmentVariablesRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.SetDeviceEnvironmentVariablesExecute(r)
}

/*
SetDeviceEnvironmentVariables Method for SetDeviceEnvironmentVariables

Set environment variables of a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiSetDeviceEnvironmentVariablesRequest
*/
func (a *DeviceAPIService) SetDeviceEnvironmentVariables(ctx context.Context, projectOrProductUID string, deviceUID string) ApiSetDeviceEnvironmentVariablesRequest {
	return ApiSetDeviceEnvironmentVariablesRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *DeviceAPIService) SetDeviceEnvironmentVariablesExecute(r ApiSetDeviceEnvironmentVariablesRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.SetDeviceEnvironmentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentVariables == nil {
		return localVarReturnValue, nil, reportError("environmentVariables is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environmentVariables
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDeviceEnvironmentVariablesByPinRequest struct {
	ctx                  context.Context
	ApiService           *DeviceAPIService
	productUID           string
	deviceUID            string
	environmentVariables *EnvironmentVariables
}

// Environment variables to be added to the device
func (r ApiSetDeviceEnvironmentVariablesByPinRequest) EnvironmentVariables(environmentVariables EnvironmentVariables) ApiSetDeviceEnvironmentVariablesByPinRequest {
	r.environmentVariables = &environmentVariables
	return r
}

func (r ApiSetDeviceEnvironmentVariablesByPinRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.SetDeviceEnvironmentVariablesByPinExecute(r)
}

/*
SetDeviceEnvironmentVariablesByPin Method for SetDeviceEnvironmentVariablesByPin

Set environment variables of a device with device pin authorization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param productUID
	@param deviceUID
	@return ApiSetDeviceEnvironmentVariablesByPinRequest
*/
func (a *DeviceAPIService) SetDeviceEnvironmentVariablesByPin(ctx context.Context, productUID string, deviceUID string) ApiSetDeviceEnvironmentVariablesByPinRequest {
	return ApiSetDeviceEnvironmentVariablesByPinRequest{
		ApiService: a,
		ctx:        ctx,
		productUID: productUID,
		deviceUID:  deviceUID,
	}
}

// Execute executes the request
//
//	@return EnvironmentVariables
func (a *DeviceAPIService) SetDeviceEnvironmentVariablesByPinExecute(r ApiSetDeviceEnvironmentVariablesByPinRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.SetDeviceEnvironmentVariablesByPin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/{productUID}/devices/{deviceUID}/environment_variables_with_pin"
	localVarPath = strings.Replace(localVarPath, "{"+"productUID"+"}", url.PathEscape(parameterValueToString(r.productUID, "productUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentVariables == nil {
		return localVarReturnValue, nil, reportError("environmentVariables is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environmentVariables
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["pin"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignalDeviceRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	body                *Body
}

// Body or payload of signal to be sent to the device
func (r ApiSignalDeviceRequest) Body(body Body) ApiSignalDeviceRequest {
	r.body = &body
	return r
}

func (r ApiSignalDeviceRequest) Execute() (*SignalDevice200Response, *http.Response, error) {
	return r.ApiService.SignalDeviceExecute(r)
}

/*
SignalDevice Method for SignalDevice

Send a signal from Notehub to a Notecard.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@return ApiSignalDeviceRequest
*/
func (a *DeviceAPIService) SignalDevice(ctx context.Context, projectOrProductUID string, deviceUID string) ApiSignalDeviceRequest {
	return ApiSignalDeviceRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
	}
}

// Execute executes the request
//
//	@return SignalDevice200Response
func (a *DeviceAPIService) SignalDeviceExecute(r ApiSignalDeviceRequest) (*SignalDevice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SignalDevice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.SignalDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/signal"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDbNoteRequest struct {
	ctx                 context.Context
	ApiService          *DeviceAPIService
	projectOrProductUID string
	deviceUID           string
	notefileID          string
	noteID              string
	note                *Note
}

// Body or payload of note to be added to the device
func (r ApiUpdateDbNoteRequest) Note(note Note) ApiUpdateDbNoteRequest {
	r.note = &note
	return r
}

func (r ApiUpdateDbNoteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDbNoteExecute(r)
}

/*
UpdateDbNote Method for UpdateDbNote

Update a note in a .db notefile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param deviceUID
	@param notefileID
	@param noteID
	@return ApiUpdateDbNoteRequest
*/
func (a *DeviceAPIService) UpdateDbNote(ctx context.Context, projectOrProductUID string, deviceUID string, notefileID string, noteID string) ApiUpdateDbNoteRequest {
	return ApiUpdateDbNoteRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		deviceUID:           deviceUID,
		notefileID:          notefileID,
		noteID:              noteID,
	}
}

// Execute executes the request
func (a *DeviceAPIService) UpdateDbNoteExecute(r ApiUpdateDbNoteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAPIService.UpdateDbNote")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/devices/{deviceUID}/notes/{notefileID}/{noteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUID"+"}", url.PathEscape(parameterValueToString(r.deviceUID, "deviceUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notefileID"+"}", url.PathEscape(parameterValueToString(r.notefileID, "notefileID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"noteID"+"}", url.PathEscape(parameterValueToString(r.noteID, "noteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.note == nil {
		return nil, reportError("note is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.note
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
