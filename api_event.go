/*
Notehub API

The OpenAPI definition for the Notehub.io API.

API version: 1.2.0
Contact: engineering@blues.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package notehub

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// EventAPIService EventAPI service
type EventAPIService service

type ApiGetEventsRequest struct {
	ctx                 context.Context
	ApiService          *EventAPIService
	projectOrProductUID string
	pageSize            *int32
	pageNum             *int32
	deviceUID           *[]string
	sortBy              *string
	sortOrder           *string
	startDate           *int32
	endDate             *int32
	dateType            *string
	systemFilesOnly     *bool
	files               *string
	format              *string
	serialNumber        *[]string
	fleetUID            *[]string
	sessionUID          *[]string
	eventUID            *[]string
	selectFields        *string
}

func (r ApiGetEventsRequest) PageSize(pageSize int32) ApiGetEventsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetEventsRequest) PageNum(pageNum int32) ApiGetEventsRequest {
	r.pageNum = &pageNum
	return r
}

// A Device UID.
func (r ApiGetEventsRequest) DeviceUID(deviceUID []string) ApiGetEventsRequest {
	r.deviceUID = &deviceUID
	return r
}

func (r ApiGetEventsRequest) SortBy(sortBy string) ApiGetEventsRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetEventsRequest) SortOrder(sortOrder string) ApiGetEventsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetEventsRequest) StartDate(startDate int32) ApiGetEventsRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetEventsRequest) EndDate(endDate int32) ApiGetEventsRequest {
	r.endDate = &endDate
	return r
}

// Which date to filter on, either &#39;captured&#39; or &#39;uploaded&#39;.  This will apply to the startDate and endDate parameters
func (r ApiGetEventsRequest) DateType(dateType string) ApiGetEventsRequest {
	r.dateType = &dateType
	return r
}

func (r ApiGetEventsRequest) SystemFilesOnly(systemFilesOnly bool) ApiGetEventsRequest {
	r.systemFilesOnly = &systemFilesOnly
	return r
}

func (r ApiGetEventsRequest) Files(files string) ApiGetEventsRequest {
	r.files = &files
	return r
}

// Response format (JSON or CSV)
func (r ApiGetEventsRequest) Format(format string) ApiGetEventsRequest {
	r.format = &format
	return r
}

// Filter by Serial Number
func (r ApiGetEventsRequest) SerialNumber(serialNumber []string) ApiGetEventsRequest {
	r.serialNumber = &serialNumber
	return r
}

// Filter by Fleet UID
func (r ApiGetEventsRequest) FleetUID(fleetUID []string) ApiGetEventsRequest {
	r.fleetUID = &fleetUID
	return r
}

// Filter by Session UID
func (r ApiGetEventsRequest) SessionUID(sessionUID []string) ApiGetEventsRequest {
	r.sessionUID = &sessionUID
	return r
}

// Filter by Event UID
func (r ApiGetEventsRequest) EventUID(eventUID []string) ApiGetEventsRequest {
	r.eventUID = &eventUID
	return r
}

// Comma-separated list of fields to select from JSON payload (e.g., \&quot;field1,field2.subfield,field3\&quot;), this will reflect the columns in the CSV output.
func (r ApiGetEventsRequest) SelectFields(selectFields string) ApiGetEventsRequest {
	r.selectFields = &selectFields
	return r
}

func (r ApiGetEventsRequest) Execute() (*GetEvents200Response, *http.Response, error) {
	return r.ApiService.GetEventsExecute(r)
}

/*
GetEvents Method for GetEvents

Get Events of a Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetEventsRequest
*/
func (a *EventAPIService) GetEvents(ctx context.Context, projectOrProductUID string) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetEvents200Response
func (a *EventAPIService) GetEventsExecute(r ApiGetEventsRequest) (*GetEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.GetEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	} else {
		var defaultValue string = "captured"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", defaultValue, "form", "")
		r.sortBy = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.dateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateType", r.dateType, "form", "")
	} else {
		var defaultValue string = "captured"
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateType", defaultValue, "form", "")
		r.dateType = &defaultValue
	}
	if r.systemFilesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemFilesOnly", r.systemFilesOnly, "form", "")
	}
	if r.files != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "files", r.files, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
		var defaultValue string = "json"
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
		r.format = &defaultValue
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		t := *r.fleetUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", t, "form", "multi")
		}
	}
	if r.sessionUID != nil {
		t := *r.sessionUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sessionUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sessionUID", t, "form", "multi")
		}
	}
	if r.eventUID != nil {
		t := *r.eventUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventUID", t, "form", "multi")
		}
	}
	if r.selectFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selectFields", r.selectFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsByCursorRequest struct {
	ctx                 context.Context
	ApiService          *EventAPIService
	projectOrProductUID string
	limit               *int32
	cursor              *string
	sortOrder           *string
	systemFilesOnly     *bool
	files               *string
	fleetUID            *string
	deviceUID           *[]string
}

func (r ApiGetEventsByCursorRequest) Limit(limit int32) ApiGetEventsByCursorRequest {
	r.limit = &limit
	return r
}

// A cursor, which can be obtained from the &#x60;next_cursor&#x60; value from a previous call to this endpoint. The results set returned will include this event as its first result if the given identifier is actually the UID of an event. If this event UID is not found, the parameter is ignored and the results set is the same as if the parameter was not included.
func (r ApiGetEventsByCursorRequest) Cursor(cursor string) ApiGetEventsByCursorRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetEventsByCursorRequest) SortOrder(sortOrder string) ApiGetEventsByCursorRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetEventsByCursorRequest) SystemFilesOnly(systemFilesOnly bool) ApiGetEventsByCursorRequest {
	r.systemFilesOnly = &systemFilesOnly
	return r
}

func (r ApiGetEventsByCursorRequest) Files(files string) ApiGetEventsByCursorRequest {
	r.files = &files
	return r
}

func (r ApiGetEventsByCursorRequest) FleetUID(fleetUID string) ApiGetEventsByCursorRequest {
	r.fleetUID = &fleetUID
	return r
}

// A Device UID.
func (r ApiGetEventsByCursorRequest) DeviceUID(deviceUID []string) ApiGetEventsByCursorRequest {
	r.deviceUID = &deviceUID
	return r
}

func (r ApiGetEventsByCursorRequest) Execute() (*GetEventsByCursor200Response, *http.Response, error) {
	return r.ApiService.GetEventsByCursorExecute(r)
}

/*
GetEventsByCursor Method for GetEventsByCursor

Get Events of a Project by cursor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetEventsByCursorRequest
*/
func (a *EventAPIService) GetEventsByCursor(ctx context.Context, projectOrProductUID string) ApiGetEventsByCursorRequest {
	return ApiGetEventsByCursorRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetEventsByCursor200Response
func (a *EventAPIService) GetEventsByCursorExecute(r ApiGetEventsByCursorRequest) (*GetEventsByCursor200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEventsByCursor200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.GetEventsByCursor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/events-cursor"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	if r.systemFilesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemFilesOnly", r.systemFilesOnly, "form", "")
	}
	if r.files != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "files", r.files, "form", "")
	}
	if r.fleetUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", r.fleetUID, "form", "")
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetEventsRequest struct {
	ctx                 context.Context
	ApiService          *EventAPIService
	projectOrProductUID string
	fleetUID            string
	pageSize            *int32
	pageNum             *int32
	deviceUID           *[]string
	sortBy              *string
	sortOrder           *string
	startDate           *int32
	endDate             *int32
	dateType            *string
	systemFilesOnly     *bool
	files               *string
	format              *string
	serialNumber        *[]string
	sessionUID          *[]string
	eventUID            *[]string
	selectFields        *string
}

func (r ApiGetFleetEventsRequest) PageSize(pageSize int32) ApiGetFleetEventsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetFleetEventsRequest) PageNum(pageNum int32) ApiGetFleetEventsRequest {
	r.pageNum = &pageNum
	return r
}

// A Device UID.
func (r ApiGetFleetEventsRequest) DeviceUID(deviceUID []string) ApiGetFleetEventsRequest {
	r.deviceUID = &deviceUID
	return r
}

func (r ApiGetFleetEventsRequest) SortBy(sortBy string) ApiGetFleetEventsRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetFleetEventsRequest) SortOrder(sortOrder string) ApiGetFleetEventsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetFleetEventsRequest) StartDate(startDate int32) ApiGetFleetEventsRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetFleetEventsRequest) EndDate(endDate int32) ApiGetFleetEventsRequest {
	r.endDate = &endDate
	return r
}

// Which date to filter on, either &#39;captured&#39; or &#39;uploaded&#39;.  This will apply to the startDate and endDate parameters
func (r ApiGetFleetEventsRequest) DateType(dateType string) ApiGetFleetEventsRequest {
	r.dateType = &dateType
	return r
}

func (r ApiGetFleetEventsRequest) SystemFilesOnly(systemFilesOnly bool) ApiGetFleetEventsRequest {
	r.systemFilesOnly = &systemFilesOnly
	return r
}

func (r ApiGetFleetEventsRequest) Files(files string) ApiGetFleetEventsRequest {
	r.files = &files
	return r
}

// Response format (JSON or CSV)
func (r ApiGetFleetEventsRequest) Format(format string) ApiGetFleetEventsRequest {
	r.format = &format
	return r
}

// Filter by Serial Number
func (r ApiGetFleetEventsRequest) SerialNumber(serialNumber []string) ApiGetFleetEventsRequest {
	r.serialNumber = &serialNumber
	return r
}

// Filter by Session UID
func (r ApiGetFleetEventsRequest) SessionUID(sessionUID []string) ApiGetFleetEventsRequest {
	r.sessionUID = &sessionUID
	return r
}

// Filter by Event UID
func (r ApiGetFleetEventsRequest) EventUID(eventUID []string) ApiGetFleetEventsRequest {
	r.eventUID = &eventUID
	return r
}

// Comma-separated list of fields to select from JSON payload (e.g., \&quot;field1,field2.subfield,field3\&quot;), this will reflect the columns in the CSV output.
func (r ApiGetFleetEventsRequest) SelectFields(selectFields string) ApiGetFleetEventsRequest {
	r.selectFields = &selectFields
	return r
}

func (r ApiGetFleetEventsRequest) Execute() (*GetEvents200Response, *http.Response, error) {
	return r.ApiService.GetFleetEventsExecute(r)
}

/*
GetFleetEvents Method for GetFleetEvents

Get Events of a Fleet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiGetFleetEventsRequest
*/
func (a *EventAPIService) GetFleetEvents(ctx context.Context, projectOrProductUID string, fleetUID string) ApiGetFleetEventsRequest {
	return ApiGetFleetEventsRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return GetEvents200Response
func (a *EventAPIService) GetFleetEventsExecute(r ApiGetFleetEventsRequest) (*GetEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.GetFleetEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", defaultValue, "form", "")
		r.pageNum = &defaultValue
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	} else {
		var defaultValue string = "captured"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", defaultValue, "form", "")
		r.sortBy = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.dateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateType", r.dateType, "form", "")
	} else {
		var defaultValue string = "captured"
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateType", defaultValue, "form", "")
		r.dateType = &defaultValue
	}
	if r.systemFilesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemFilesOnly", r.systemFilesOnly, "form", "")
	}
	if r.files != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "files", r.files, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
		var defaultValue string = "json"
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
		r.format = &defaultValue
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", t, "form", "multi")
		}
	}
	if r.sessionUID != nil {
		t := *r.sessionUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sessionUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sessionUID", t, "form", "multi")
		}
	}
	if r.eventUID != nil {
		t := *r.eventUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventUID", t, "form", "multi")
		}
	}
	if r.selectFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selectFields", r.selectFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFleetEventsByCursorRequest struct {
	ctx                 context.Context
	ApiService          *EventAPIService
	projectOrProductUID string
	fleetUID            string
	limit               *int32
	cursor              *string
	sortOrder           *string
	systemFilesOnly     *bool
	files               *string
	deviceUID           *[]string
	startDate           *int32
	endDate             *int32
}

func (r ApiGetFleetEventsByCursorRequest) Limit(limit int32) ApiGetFleetEventsByCursorRequest {
	r.limit = &limit
	return r
}

// A cursor, which can be obtained from the &#x60;next_cursor&#x60; value from a previous call to this endpoint. The results set returned will include this event as its first result if the given identifier is actually the UID of an event. If this event UID is not found, the parameter is ignored and the results set is the same as if the parameter was not included.
func (r ApiGetFleetEventsByCursorRequest) Cursor(cursor string) ApiGetFleetEventsByCursorRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetFleetEventsByCursorRequest) SortOrder(sortOrder string) ApiGetFleetEventsByCursorRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetFleetEventsByCursorRequest) SystemFilesOnly(systemFilesOnly bool) ApiGetFleetEventsByCursorRequest {
	r.systemFilesOnly = &systemFilesOnly
	return r
}

func (r ApiGetFleetEventsByCursorRequest) Files(files string) ApiGetFleetEventsByCursorRequest {
	r.files = &files
	return r
}

// A Device UID.
func (r ApiGetFleetEventsByCursorRequest) DeviceUID(deviceUID []string) ApiGetFleetEventsByCursorRequest {
	r.deviceUID = &deviceUID
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetFleetEventsByCursorRequest) StartDate(startDate int32) ApiGetFleetEventsByCursorRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetFleetEventsByCursorRequest) EndDate(endDate int32) ApiGetFleetEventsByCursorRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetFleetEventsByCursorRequest) Execute() (*GetEventsByCursor200Response, *http.Response, error) {
	return r.ApiService.GetFleetEventsByCursorExecute(r)
}

/*
GetFleetEventsByCursor Method for GetFleetEventsByCursor

Get Events of a Fleet by cursor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param fleetUID
	@return ApiGetFleetEventsByCursorRequest
*/
func (a *EventAPIService) GetFleetEventsByCursor(ctx context.Context, projectOrProductUID string, fleetUID string) ApiGetFleetEventsByCursorRequest {
	return ApiGetFleetEventsByCursorRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		fleetUID:            fleetUID,
	}
}

// Execute executes the request
//
//	@return GetEventsByCursor200Response
func (a *EventAPIService) GetFleetEventsByCursorExecute(r ApiGetFleetEventsByCursorRequest) (*GetEventsByCursor200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEventsByCursor200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.GetFleetEventsByCursor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/fleets/{fleetUID}/events-cursor"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fleetUID"+"}", url.PathEscape(parameterValueToString(r.fleetUID, "fleetUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	if r.systemFilesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemFilesOnly", r.systemFilesOnly, "form", "")
	}
	if r.files != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "files", r.files, "form", "")
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRouteLogsByEventRequest struct {
	ctx                 context.Context
	ApiService          *EventAPIService
	projectOrProductUID string
	eventUID            string
}

func (r ApiGetRouteLogsByEventRequest) Execute() ([]RouteLog, *http.Response, error) {
	return r.ApiService.GetRouteLogsByEventExecute(r)
}

/*
GetRouteLogsByEvent Method for GetRouteLogsByEvent

Get Route Logs by Event UID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@param eventUID
	@return ApiGetRouteLogsByEventRequest
*/
func (a *EventAPIService) GetRouteLogsByEvent(ctx context.Context, projectOrProductUID string, eventUID string) ApiGetRouteLogsByEventRequest {
	return ApiGetRouteLogsByEventRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
		eventUID:            eventUID,
	}
}

// Execute executes the request
//
//	@return []RouteLog
func (a *EventAPIService) GetRouteLogsByEventExecute(r ApiGetRouteLogsByEventRequest) ([]RouteLog, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RouteLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.GetRouteLogsByEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/events/{eventUID}/route-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventUID"+"}", url.PathEscape(parameterValueToString(r.eventUID, "eventUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
