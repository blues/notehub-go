/*
Notehub API

The OpenAPI definition for the Notehub.io API.

API version: 1.2.0
Contact: engineering@blues.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package notehub

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// UsageAPIService UsageAPI service
type UsageAPIService service

type ApiGetDataUsageRequest struct {
	ctx                 context.Context
	ApiService          *UsageAPIService
	projectOrProductUID string
	period              *string
	startDate           *int32
	endDate             *int32
	deviceUID           *[]string
	fleetUID            *[]string
	aggregate           *string
}

// Period type for aggregation
func (r ApiGetDataUsageRequest) Period(period string) ApiGetDataUsageRequest {
	r.period = &period
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetDataUsageRequest) StartDate(startDate int32) ApiGetDataUsageRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetDataUsageRequest) EndDate(endDate int32) ApiGetDataUsageRequest {
	r.endDate = &endDate
	return r
}

// A Device UID.
func (r ApiGetDataUsageRequest) DeviceUID(deviceUID []string) ApiGetDataUsageRequest {
	r.deviceUID = &deviceUID
	return r
}

// Filter by Fleet UID
func (r ApiGetDataUsageRequest) FleetUID(fleetUID []string) ApiGetDataUsageRequest {
	r.fleetUID = &fleetUID
	return r
}

// Aggregation level for results
func (r ApiGetDataUsageRequest) Aggregate(aggregate string) ApiGetDataUsageRequest {
	r.aggregate = &aggregate
	return r
}

func (r ApiGetDataUsageRequest) Execute() (*GetDataUsage200Response, *http.Response, error) {
	return r.ApiService.GetDataUsageExecute(r)
}

/*
GetDataUsage Method for GetDataUsage

Get data usage in bytes for a project with time range and period aggregation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetDataUsageRequest
*/
func (a *UsageAPIService) GetDataUsage(ctx context.Context, projectOrProductUID string) ApiGetDataUsageRequest {
	return ApiGetDataUsageRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetDataUsage200Response
func (a *UsageAPIService) GetDataUsageExecute(r ApiGetDataUsageRequest) (*GetDataUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDataUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.GetDataUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/usage/data"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		t := *r.fleetUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "form", "")
	} else {
		var defaultValue string = "device"
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", defaultValue, "form", "")
		r.aggregate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsUsageRequest struct {
	ctx                 context.Context
	ApiService          *UsageAPIService
	projectOrProductUID string
	period              *string
	startDate           *int32
	endDate             *int32
	deviceUID           *[]string
	fleetUID            *[]string
	aggregate           *string
	notefile            *[]string
	skipRecentData      *bool
	includeNotefiles    *bool
}

// Period type for aggregation
func (r ApiGetEventsUsageRequest) Period(period string) ApiGetEventsUsageRequest {
	r.period = &period
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetEventsUsageRequest) StartDate(startDate int32) ApiGetEventsUsageRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetEventsUsageRequest) EndDate(endDate int32) ApiGetEventsUsageRequest {
	r.endDate = &endDate
	return r
}

// A Device UID.
func (r ApiGetEventsUsageRequest) DeviceUID(deviceUID []string) ApiGetEventsUsageRequest {
	r.deviceUID = &deviceUID
	return r
}

// Filter by Fleet UID
func (r ApiGetEventsUsageRequest) FleetUID(fleetUID []string) ApiGetEventsUsageRequest {
	r.fleetUID = &fleetUID
	return r
}

// Aggregation level for results
func (r ApiGetEventsUsageRequest) Aggregate(aggregate string) ApiGetEventsUsageRequest {
	r.aggregate = &aggregate
	return r
}

// Filter to specific notefiles
func (r ApiGetEventsUsageRequest) Notefile(notefile []string) ApiGetEventsUsageRequest {
	r.notefile = &notefile
	return r
}

// When true, skips fetching recent data from raw event tables and only returns data from summary tables. Use this for better performance on large projects.
func (r ApiGetEventsUsageRequest) SkipRecentData(skipRecentData bool) ApiGetEventsUsageRequest {
	r.skipRecentData = &skipRecentData
	return r
}

// Include per-notefile event counts in the response
func (r ApiGetEventsUsageRequest) IncludeNotefiles(includeNotefiles bool) ApiGetEventsUsageRequest {
	r.includeNotefiles = &includeNotefiles
	return r
}

func (r ApiGetEventsUsageRequest) Execute() (*UsageEventsResponse, *http.Response, error) {
	return r.ApiService.GetEventsUsageExecute(r)
}

/*
GetEventsUsage Method for GetEventsUsage

Get events usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetEventsUsageRequest
*/
func (a *UsageAPIService) GetEventsUsage(ctx context.Context, projectOrProductUID string) ApiGetEventsUsageRequest {
	return ApiGetEventsUsageRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return UsageEventsResponse
func (a *UsageAPIService) GetEventsUsageExecute(r ApiGetEventsUsageRequest) (*UsageEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UsageEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.GetEventsUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/usage/events"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		t := *r.fleetUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "form", "")
	} else {
		var defaultValue string = "device"
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", defaultValue, "form", "")
		r.aggregate = &defaultValue
	}
	if r.notefile != nil {
		t := *r.notefile
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notefile", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notefile", t, "form", "multi")
		}
	}
	if r.skipRecentData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipRecentData", r.skipRecentData, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipRecentData", defaultValue, "form", "")
		r.skipRecentData = &defaultValue
	}
	if r.includeNotefiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNotefiles", r.includeNotefiles, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNotefiles", defaultValue, "form", "")
		r.includeNotefiles = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRouteLogsUsageRequest struct {
	ctx                 context.Context
	ApiService          *UsageAPIService
	projectOrProductUID string
	period              *string
	startDate           *int32
	endDate             *int32
	routeUID            *[]string
	aggregate           *string
	skipRecentData      *bool
}

// Period type for aggregation
func (r ApiGetRouteLogsUsageRequest) Period(period string) ApiGetRouteLogsUsageRequest {
	r.period = &period
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetRouteLogsUsageRequest) StartDate(startDate int32) ApiGetRouteLogsUsageRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetRouteLogsUsageRequest) EndDate(endDate int32) ApiGetRouteLogsUsageRequest {
	r.endDate = &endDate
	return r
}

// A Route UID.
func (r ApiGetRouteLogsUsageRequest) RouteUID(routeUID []string) ApiGetRouteLogsUsageRequest {
	r.routeUID = &routeUID
	return r
}

// Aggregation level for results
func (r ApiGetRouteLogsUsageRequest) Aggregate(aggregate string) ApiGetRouteLogsUsageRequest {
	r.aggregate = &aggregate
	return r
}

// When true, skips fetching recent data from raw event tables and only returns data from summary tables. Use this for better performance on large projects.
func (r ApiGetRouteLogsUsageRequest) SkipRecentData(skipRecentData bool) ApiGetRouteLogsUsageRequest {
	r.skipRecentData = &skipRecentData
	return r
}

func (r ApiGetRouteLogsUsageRequest) Execute() (*GetRouteLogsUsage200Response, *http.Response, error) {
	return r.ApiService.GetRouteLogsUsageExecute(r)
}

/*
GetRouteLogsUsage Method for GetRouteLogsUsage

Get route logs usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetRouteLogsUsageRequest
*/
func (a *UsageAPIService) GetRouteLogsUsage(ctx context.Context, projectOrProductUID string) ApiGetRouteLogsUsageRequest {
	return ApiGetRouteLogsUsageRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetRouteLogsUsage200Response
func (a *UsageAPIService) GetRouteLogsUsageExecute(r ApiGetRouteLogsUsageRequest) (*GetRouteLogsUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRouteLogsUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.GetRouteLogsUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/usage/route-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.routeUID != nil {
		t := *r.routeUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routeUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routeUID", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "form", "")
	} else {
		var defaultValue string = "route"
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", defaultValue, "form", "")
		r.aggregate = &defaultValue
	}
	if r.skipRecentData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipRecentData", r.skipRecentData, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipRecentData", defaultValue, "form", "")
		r.skipRecentData = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSessionsUsageRequest struct {
	ctx                 context.Context
	ApiService          *UsageAPIService
	projectOrProductUID string
	period              *string
	startDate           *int32
	endDate             *int32
	deviceUID           *[]string
	fleetUID            *[]string
	aggregate           *string
	skipRecentData      *bool
}

// Period type for aggregation
func (r ApiGetSessionsUsageRequest) Period(period string) ApiGetSessionsUsageRequest {
	r.period = &period
	return r
}

// Start date for filtering results, specified as a Unix timestamp
func (r ApiGetSessionsUsageRequest) StartDate(startDate int32) ApiGetSessionsUsageRequest {
	r.startDate = &startDate
	return r
}

// End date for filtering results, specified as a Unix timestamp
func (r ApiGetSessionsUsageRequest) EndDate(endDate int32) ApiGetSessionsUsageRequest {
	r.endDate = &endDate
	return r
}

// A Device UID.
func (r ApiGetSessionsUsageRequest) DeviceUID(deviceUID []string) ApiGetSessionsUsageRequest {
	r.deviceUID = &deviceUID
	return r
}

// Filter by Fleet UID
func (r ApiGetSessionsUsageRequest) FleetUID(fleetUID []string) ApiGetSessionsUsageRequest {
	r.fleetUID = &fleetUID
	return r
}

// Aggregation level for results
func (r ApiGetSessionsUsageRequest) Aggregate(aggregate string) ApiGetSessionsUsageRequest {
	r.aggregate = &aggregate
	return r
}

// When true, skips fetching recent data from raw event tables and only returns data from summary tables. Use this for better performance on large projects.
func (r ApiGetSessionsUsageRequest) SkipRecentData(skipRecentData bool) ApiGetSessionsUsageRequest {
	r.skipRecentData = &skipRecentData
	return r
}

func (r ApiGetSessionsUsageRequest) Execute() (*GetSessionsUsage200Response, *http.Response, error) {
	return r.ApiService.GetSessionsUsageExecute(r)
}

/*
GetSessionsUsage Method for GetSessionsUsage

Get sessions usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectOrProductUID
	@return ApiGetSessionsUsageRequest
*/
func (a *UsageAPIService) GetSessionsUsage(ctx context.Context, projectOrProductUID string) ApiGetSessionsUsageRequest {
	return ApiGetSessionsUsageRequest{
		ApiService:          a,
		ctx:                 ctx,
		projectOrProductUID: projectOrProductUID,
	}
}

// Execute executes the request
//
//	@return GetSessionsUsage200Response
func (a *UsageAPIService) GetSessionsUsageExecute(r ApiGetSessionsUsageRequest) (*GetSessionsUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetSessionsUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.GetSessionsUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectOrProductUID}/usage/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"projectOrProductUID"+"}", url.PathEscape(parameterValueToString(r.projectOrProductUID, "projectOrProductUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.deviceUID != nil {
		t := *r.deviceUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceUID", t, "form", "multi")
		}
	}
	if r.fleetUID != nil {
		t := *r.fleetUID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fleetUID", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "form", "")
	} else {
		var defaultValue string = "device"
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", defaultValue, "form", "")
		r.aggregate = &defaultValue
	}
	if r.skipRecentData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipRecentData", r.skipRecentData, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipRecentData", defaultValue, "form", "")
		r.skipRecentData = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
